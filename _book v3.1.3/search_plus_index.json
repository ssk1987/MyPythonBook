{"./":{"url":"./","title":"序言","keywords":"","body":"Our Python Basic Book [V3.1.3] 一直都有一个愿望：想把自己所学的知识都总结成一个完整的知识体系文档站点。 苦于自己毅力不够，往往做了东就忘了西，瞎折腾这么多年都没有完成(很多半成品)，眼下又开始折腾了，希望这次能够坚持下去。 课程推荐的学习方法 学习方法 当天的知识必须理解 What 是什么？ 即理解知识点的定义 Why 为什么？ 即理解知识点的作用 Where 在哪里？ 即理解知识点的适用性 How 如何使用？ 即理解知识点的语法 弱语法，重本质 是一种弱化语言规则，注重程序原理的学习过程。 语法是表象，只有了解深层机理，才能灵活运用。 学习编程要深入内存，剖析原理，才能看清语法。 就像太极“用意不用力，先在心后在身”的道理。 重思想，重设计 思想是解决问题的思维方式，设计指编写程序结构的过程。 通过面向对象三大特征，六大原则学习设计思想。 通过信息管理系统了解 MVC 设计思想。 通过天龙八部技能系统体会设计思想。 通过“全国面向对象课程答辩”总结设计思想。 GitBook文档 如果你也想拥有一个和本站一样的文档站点：请参考： http://www.python87.com/technology/gitbook_create.html Markdown语法 http://www.python87.com/markdown/index.html Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 10:18:39 "},"Journal.html":{"url":"Journal.html","title":"更新日志","keywords":"","body":"更新日志 详细更新记录 V3.1.2 版本更新记录 Updata time: 2020/01/03 [!] [容器/序列] 网络相关 + 增加 常用小技巧代码 [*] 包、模块 + 增加 案例:项目内各个包内的模块怎么互相调用??? [*] 设计模式 + 增加 单例模式 + 迭代器模式 + 解释器模式 [*] 面向对象 + 增加 魔法方法 目录及内容 [!] 函数式编程 + 修改 闭包内容 [!] 语句 + 修改 if嵌套内容 + 增加 应用:猜拳游戏 [!] 数据基本运算 + 修改 数据类型转换 V3.1.1 版本更新记录 Updata time: 2020/01/02 [*] 序言 + 弱语法，重本质 + 重思想，重设计 [*] 函数传参 + 增加2个星号元组的练习题 [!] 练习项目 + 2048游戏 目录 + 天龙八部技能系统 目录 + 学生管理系统 目录 + 集成操作系统 目录 [*] 时间模块 + 相关函数说明及演示代码 [*] 变量 + 内存图和演示代码 [*] del语句 + 内存图和演示代码 V3.0 版本更新记录 Updata time: 2019/12/30 1. 在v1.0~v2.0的版本基础上合并为一个新的gitbook版(.md/html)。 2. 面面向对象的设计模式,开闭,单一原则,组合...一系列的想法构成我使用gitbook来管理自己的文档。 3. 虽说v1.0也有面向对象的思想,但是站点每次都需要登录后修改,每创建一个新的栏目都需要自己手写源码,不如统一简单风格的md来的适用。 V2.0 版本更新记录 Updata time: 2019/11/19 1. 在v1.0的基础上，整理成 markdown 版本。 2. .md 文档虽简便,但是所有知识点及素材都集中在一个或多个.md文档里，过于臃肿,故此继续寻找更为合适的展现方式。 V1.0 版本更新记录 Updata time: 2019/08/22 1. 创建python87.com文档站点,将自学的知识整理发布在站点中。 2. 随着知识积累的越多,发现每天将花费大量的时间来打理站点,特此在寻找更为合适的展现方式。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 22:06:53 "},"contributor/":{"url":"contributor/","title":"共同维护者","keywords":"","body":"笔记维护者名单(排名不分先后) 一个人的思维是局限的,聚焦全国Python爱好者一起共同学习,共同进步!!! 序 号 姓 名 / 笔 名 地 区 / 城 市 01 None.K.Sun 南京 02 if 北京 03 徐辉平 深圳 04 李晓 北京 05 巨轮 广州 06 纪高凡 山东 07 紫涩Dè回忆 　 如果您也喜欢Python,愿意为此贡献微薄之力,可以联系站长 分享给广大Python爱好者 ---> 笔记下载地址：[ 点击下载 ] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 16:33:34 "},"chapter01/":{"url":"chapter01/","title":"Python简介","keywords":"","body":"Chapter02 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 21:50:18 "},"chapter01/1_02.html":{"url":"chapter01/1_02.html","title":"Python介绍","keywords":"","body":"Python介绍 【我也不喜欢看大段的文字，既然要学这门语言，那必要的文字介绍还是要看的哈】 小时不识月，呼作白玉盘。很多人习惯地（甚至还会配合着鄙夷的眼神和标签）说Python不过是一种脚本语言而已，实际上这种说法是非常不准确的，完全不能体现出Python的强大。严格来说，Python是一门跨平台、开源、免费的解释型高级动态编程语言。除了解释执行，Python还支持伪编译将源代码转换为字节码来优化程序提高运行速度和对源代码进行保密，并且支持使用py2exe、pyinstaller、cx\\_Freeze或其他类似工具将Python程序及其所有依赖库打包为扩展名为exe的可执行程序，从而可以脱离Python解释器环境和相关依赖库而在Windows平台上独立运行；Python支持命令式编程、函数式编程，完全支持面向对象程序设计，语法简洁清晰，并且拥有大量的几乎支持所有领域应用开发的成熟扩展库；也有人喜欢把Python称为“胶水语言”，因为它可以把多钟不同语言编写的程序融合到一起实现无缝连接，更好地发挥不同语言和工具的优势，满足不同领域的需求。 Python是一种解释型、面向对象的语言。 由吉多·范罗苏姆（Guido van Rossum）于1989年发明，1991年正式公布。官网： www.python.org Python单词是“大蟒蛇”的意思。但是龟叔不是喜欢蟒蛇才起这个名字，而是正在追剧：英国电视喜剧片《蒙提·派森的飞行马戏团》(Monty Python and the Flying Circus)。 特点 1.可读性强 可读性远比听上去重要的多得多。一个程序会被反复的修改，可读性强意味着让你可以在更短时间内学习和记忆，直接提高生产率。 2.简洁，简洁，简洁 研究证明，程序员每天可编写的有效代码数是有限的。完成同样功能只用一半的代码，其实就是提高了一倍的生产率。Python是由 C语言开发，但是不再有 C语言中指针等复杂数据类型，Python的简洁性让开发难度和代码幅度大幅降低，开发任务大大简化。程序员再也不需要关注复杂的语法，而是关注任务本身。 1.面向对象 2.免费和开源 3.可移植性和跨平台 Python会被编译成与操作系统相关的二进制代码，然后再解释执行。这种方式和java类似，大大提高了执行速度，也实现了跨平台。 1.丰富的库（丰富的标准库，多种多样的扩展库） 2.可扩展性。可嵌入到 C和 C++语言。胶水式语言。 应用范围 1.科学计算 2.人工智能 3.WEB服务端和大型网站后端。YouTube、gmail等应用基于 python开发。 4.GUI开发（图形用户界面开发） 5.游戏开发 6.移动设备 7.嵌入式设备 8.系统运维 9.大数据 10.云计算 什么时候不应该用 Python Python是解释执行。性能较低。因此，一些影响性能的功能可以使用 C/C++/JAVA/GO（GO是一种新语言，写起了像 Python，性能像 C）去开发。 不过，不用担心 Python解释器会越来越快。 版本和兼容问题解决方案 目前主要两个版本：Python2和 Python3 Python2： 2000年 10月发布。最新版本是 2.7，已经停止更新，不会再有 2.8以后了。预计2020年退出历史舞台。 Python3： 2008年发布。Python3有了较大的提升，不兼容 Python2。 兼容问题解决： Python3的很多新特性也被移植到了 Python2.7，作为过渡。如果程序可以在 2.7运行，可以通过一个名为 2to3（Python自带的一个脚本）的转换工具无缝迁移到 Python3. 2.建议大家学习从 Python3开始，毕竟这才是未来。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 16:12:32 "},"chapter01/1_03.html":{"url":"chapter01/1_03.html","title":"Python解释器","keywords":"","body":"Python程序的执行依赖于 Python解释器。 常用的 Python解释器有： CPython使用 c语言实现的解释器，最常用的解释器。通常说的解释器指的就它。 Jython使用 java语言实现的解释器。Jython可以直接调用 java类库，适合在 java平台上开发 IronPython.NET平台上使用的解释器。可直接调用.NET平台的类，适合.NET平台上开发 PyPy使用 Python语言实现的解释器 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 16:12:32 "},"chapter01/1_04.html":{"url":"chapter01/1_04.html","title":"赋值","keywords":"","body":"链式赋值 通俗讲：链式赋值是将同一个值赋给多个变量，有点像并行赋值； 简单讲：链式赋值用于同一个对象赋值给多个变量； x = y = 123 相当于 x = 123; y = 123; 系列解包赋值 序列解包是将多个赋值操作同时进行的方法：将多个值的序列解开，然后放到变量的序列中； 系列数据赋值给对应相同个数的变量（个数必须保持一致）。 a,b,c = 4,5,6 相当于 a = 4; b = 5; c = 6; 操作： 使用系列解包赋值实现变量互换 a,b = 1,2 a,b = b,a print(a,b) 增量赋值 增量赋值就是将一个变量进行表达式后重新赋给变量，如 x = x + 1。 x = 3 x += 1 print(x) # 4 y = 1 y = y + 1 print(y) # 2 x *= 2 print(x) # 8 s = 'job' s += 'name' print(s) # jobname 字符串拼接 s *= 3 print(s) # jobnamejobnamejobname 注意事项： 1、在序列解包的时候赋值符号左边的变量数目和序列中的元素数目是完全一致的； 2、所谓增量赋值对于 “*”，“/”, “%” 等标准运算符都是成立的； 序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。 >>> x,y,z = (10,20,30) >>> x 10 >>> y 20 >>> z 30 >>> (a,b,c) = (8,9,10) >>> a 8 >>> b 9 >>> c 10 >>> [a,b,c] = [10,20,30] >>> a 10 >>> b 20 >>> c 30 序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用 items()； 如果需要对“值”进行操作，则需要使用 values()。 # 定义一个字典 a >>> a = {'name':'Python','age':87,'job':'teacher'} >>> a {'name': 'Python', 'age': 87, 'job': 'teacher'} # 默认是对 键 进行操作 >>> x,y,z = a >>> x 'name' >>> y 'age' >>> z 'job' # 对 键值对 进行操作 >>> x1,y1,z1 = a.items() >>> x1 ('name', 'Python') >>> y1 ('age', 87) >>> z1 ('job', 'teacher') # 对 值 进行操作 >>> x2,y2,z2 = a.values() >>> x2 'Python' >>> y2 87 >>> z2 'teacher' Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 16:12:32 "},"chapter01/1_05.html":{"url":"chapter01/1_05.html","title":"IDLE开发环境入门","keywords":"","body":"IDLE 介绍 IDLE 是Python 的官方标准开发环境，Python 安装完后同时就安装了IDLE。 IDLE 已经具备了Python 开发几乎所有功能（语法智能提示、不同颜色显示不同类型等等），也不需要其他配置，非常适合初学者使用。 IDLE 是Python 标准发行版内置的一个简单小巧的IDE，包括了交互式命令行、编辑器、调试器等基本组件，足以应付大多数简单应用。 IDLE 是用纯Python 基于Tkinter 编写，最初的作者正是Python 之父Guido vanRossum。 IDLE 实操 交互模式 启动IDLE，默认就是进入交互模式。 编写和执行Python 源文件 IDLE 常用快捷键 快捷键 说明 ALT+N ALT+P 查看历史命令上一条、下一条 Ctrl + F6 重启 shell，以前定义的变量全部失效 F1 打开帮助文档 Alt + / 自动补全前面曾经出现过的单词 Ctrl + [ 缩进代码和取消缩进 Alt + M 打开模块代码，先选择模块，然后按下此快捷键，会帮你打开该模块的py源码供浏览 Alt + C 打开类浏览器，方便在源码文件中的各个方法体之间切换 F5 运行程序 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 16:12:32 "},"chapter01/1_06.html":{"url":"chapter01/1_06.html","title":"第一个Python程序","keywords":"","body":"第一个Python程序 交互模式下： 【源码】： print\\(\"a\"\\) print\\(\"b\"\\) print\\(\"c\"\\) 将源代码保存到：d/python_exec/mypy01.py 在IDLE中单击F5或者 run --> run module 执行这个源程序。 第一个Python程序中需要注意的小要点： 1、不要在程序中，行开头处增加空格。空格在Python中有缩进的含义。 2、符号都是英文符号，不是中文。比如： # 中英文符号对比 # 英文符号 for i in range(5): print(i) # 中文符号 for i in range（5）： print（i） # 程序中使用中文符号会报错 程序执行结果 File \"33.py\", line 8 for i in range（5）： ^ SyntaxError: invalid character in identifier Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:08:43 "},"chapter01/1_07.html":{"url":"chapter01/1_07.html","title":"程序基本格式","keywords":"","body":"程序基本格式 1、恰当的空格，缩进问题 1) 逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而来决定语句的分组。 2) 语句从新行的第一列开始。 3) 缩进风格统一： (1) 每个缩进层次使用 单个制表符 或 四个空格（IDE会自动将制表符设置成4个空格） (2) Python 用缩进而不是 {} 表示程序块。 2、Python区分大小写 3、注释 1) 行注释 每行注释前加#号。当解释器看到 # ，则忽略这一行#后面的内容 2) 段注释 使用三个单引号（ ''' ）。当解释器看到 ''' ，则会扫描到下一个 '''，然后忽略他们之间的内容。 【操作演示】 # Python 区分大小写 # 设置变量 A1 和 a1 >>> A1 = 100 >>> a1 = 60 >>> A1 - a1 40 # 这个就是 行注释 ''' 看到没有,三个单引号之间的内容是会被Python解释器忽略的 我这会也会被忽略 你看我是第三行，也是被忽略的 ''' Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:09:40 "},"chapter01/1_08.html":{"url":"chapter01/1_08.html","title":"PyCharm常用快捷键","keywords":"","body":"PyCharm 快捷键总结 以下快捷键可以逐一测试，记住自己常用的快捷键即可。 如果按下去没有效果，看看自己电脑上安装的其他软件是否有快捷键冲突； 反正这辈子全部记住是不可能的了，就记住常用的几个即可，其他的作为日后参考资料。以备日后查阅方便。 pycharm相关设置 1.“代码自动完成”时间延时设置 File -> Settings -> Editor -> General -> Code Completion -> Autopopup in (ms):0 2.快捷键： Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Ctrl + Alt + M 提取方法 移动到本行开头：home键 移动到本行末尾：end键盘 注释代码：ctrl + / 复制行：ctrl +d 选择列：鼠标左键 + alt 移动行：shift + alt + 上下箭头 智能提示：ctrl + Space 快捷键格式化代码 ctrl+alt+L 默认的快捷方式（如果你的PyCharm被自己手动修改过，则下面的快捷键对你无效） 1、编辑（Editing） Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 F1 外部文档 Shift + F1 外部文档，进入web文档主页 Ctrl + Shift + Z --> Redo 重做 Ctrl + 悬浮/单击鼠标左键 简介/进入代码定义 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释/取消行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开/折叠代码块（当前位置的：函数，注释等） Ctrl + shift + Numpad+/- 展开/折叠所有代码块 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 或者连续2次敲击shift 全局查找{可以在整个项目中查找某个字符串什么的，如查找某个函数名字符串看之前是怎么使用这个函数的} Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡（代码文件） Alt + Up/Down跳转到上一个、下一个方法 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出，打开最近使用的文件列表 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 {差不多就是返回上次编辑的位置} Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制 F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(’)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(’)快速切换当前计划 Ctrl + Alt + S　打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:26:14 "},"chapter01/1_09.html":{"url":"chapter01/1_09.html","title":"Python常量","keywords":"","body":"Python常量 Python不支持常量 即没有语法规则限制改变一个常量的值。我们只能约定常量的命名规则，以及在程序逻辑上不对常量的值作出修改。 如何定义常量：全部大写，多个单词使用__下划线隔开。如： _MY_NAME_IS = \"Python87.com\" MAX_SPEED = 120 print(MAX_SPEED) # 120 MAX_SPEED = 140 # 实际是可以改的。只是逻辑上不做修改。 print(MAX_SPEED) # 140 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:25:07 "},"chapter01/1_10.html":{"url":"chapter01/1_10.html","title":"Python程序的执行过程","keywords":"","body":"Python程序的执行过程 计算机只能识别机器码(1010)，不能识别源代码(python)。 1.由源代码转变成机器码的过程分成两类：编译和解释。 2.编译：在程序运行之前，通过编译器将源代码变成机器码，例如：C语言。 -- 优点：运行速度快 -- 缺点：开发效率低，不能跨平台。 3.解释：在程序运行之时，通过解释器对程序逐行翻译，然后执行。例如Javascript -- 优点：开发效率高，可以跨平台； -- 缺点：运行速度慢。 4.python是解释型语言，但为了提高运行速度，使用了一种编译的方法。编译之后得到pyc文件，存储了字节码（特定于Python的表现形式，不是机器码）。 源代码 -- 编译 --> 字节码 -- 解释 --> 机器码 |————1次———| 执行过程演示图： Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 10:21:13 "},"chapter01/pep8.html":{"url":"chapter01/pep8.html","title":"PEP8编码规范","keywords":"","body":"PEP8编码规范 代码编排 使用4空格缩进，不使用Tab,更不允许用Tab和空格混合缩进； 每行最大长度最大79字节，超过部分使用反斜杠折行； 类和全局函数定义间隔两个空行,类内方法定义间隔一个空行.其它地方可以不加空行。 文档编排 其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。 不要在一句import中导入多个模块，比如不推荐import os, sys。 尽可能用import XX 而不采用from XX import YY引用库,因为可能出现名字冲突。 空格的使用 各种右括号前不用加空格。 逗号、冒号、分号前不要加空格。 函数的左括号前不要加空格。如func(1)。 序列的左括号前不要加空格。如list[2]。 操作符左右各加一个空格，不要为了对齐增加空格。 函数默认参数使用的赋值符左右省略空格。 不要将多条语句写在同一行，尽管使用‘;’允许。 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 【原则】：避免不必要的空格 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 18:13:36 "},"chapter01/basic_time.html":{"url":"chapter01/basic_time.html","title":"时间模块 time","keywords":"","body":"时间模块 时间模块 此模块提供了时间相关的函数，且一直可用。 时间简介 Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。 公元纪年是从公元 0000年1月1日0时开始的 计算机中时间的表示是从“1970年 1月 1日 00:00:00”开始，以毫秒（1/1000秒）进行计算,之后每过一秒时间+1。 我们也把 1970年这个时刻成为“unix时间点”。这样，我们就把时间全部用数字来表示了。 python中可以通过 time.time()获得当前时刻，返回的值是以秒为单位，带微秒（1/1000毫秒）精度的浮点值。例如：1530167364.8566。 UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的. UTC 时间不会因时区问题而产生错误 DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间 时间模块的使用 导入方式 import time # 或 from time import xxx # 或 from time import * 数据 描述 time.altzone 夏令时时间与UTC时间差(秒为单位) time.daylight 夏令时校正时间 time.timezone 本地区时间与UTC时间差(秒为单位) time.tzname 时区名字的元组，第一个名字为未经夏令时修正的时区名,第一个名字为经夏令时修正后的时区名 注： CST为中国标准时间(China Standard Time UTC+8:00) 时间相关函数 函数名 描述 time.time() 返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准) time.gmtime([secs]) 用给定秒数转换为用UTC表达的时间元组(缺省返回当前时间元组) time.localtime([secs]) 将UTC秒数时间转换为日期元组（以本地时间为准) time.mktime(tuple) 将本地日期时间元组转换为新纪元秒数时间(UTC为准) time.asctime([tuple]) 将时间元组转换为日期时间字符串 time.sleep(secs) 让程序按给定秒数的浮点数睡眠一段时间 时间元祖 时间元组是一个9个整型元素组成的,这九个元素自前至后依次为: 四位的年(如: 1993) 月 (1-12) 日 (1-31) 时 (0-23) 分 (0-59) 秒 (0-59) 星期几 (0-6, 周一是 0) 元旦开始日 (1-366) 夏令时修正时间 (-1, 0 or 1). 注： 如果年份值小于100,则会自动转换为加上1900后的值 模块名: time import time # 获取时间元祖 gmt = time.gmtime() print(gmt) \"\"\" time.struct_time( tm_year=2020, 年 tm_mon=1, 月 tm_mday=2, 日 tm_hour=9, 时 tm_min=20, 分 tm_sec=17, 秒 tm_wday=3, 星期(从0开始算起) tm_yday=2, 一个月的第几天 tm_isdst=0 夏令时(几乎用不到) ) \"\"\" 获取时间戳 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 import time timestamp = time.time() print(timestamp) 执行结果：1577956749.8488483 【操作】源代码： import time # 获取当前时间为止的整型 秒 a = int(time.time()) # 获取 分钟 m = a / 60 # 这样获取的是浮点数，我们为了方便计算都取整数 m = a // 60 # 1分钟 = 60秒 # 获取 小时 h = m // 60 # 1小时 = 60分钟 # 获取 天 d = h // 24 # 1天 = 24小时 # 获取 年 y = d // 365 # 1年 = 365天 这里不考虑闰月什么的 print(y) # 49 时间字符串 --> 时间元祖 strptime(时间字符串，时间字符串的格式),前后两个参数格式相同，可以自定义 import time year = int(input(\"请输入年份：\")) month = int(input(\"请输入月份：\")) day = int(input(\"请输入日期：\")) hour = int(input(\"请输入小时：\")) tuple_time = time.strptime(\"%d-%d-%d\" % (year, month, day), \"%Y-%m-%d\") print(tuple_time) 执行结果： 请输入年份：2020 请输入月份：1 请输入日期：1 请输入小时：12 time.struct_time(tm_year=2020, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=1, tm_isdst=-1) 时间元祖 --> 时间戳 使用 time.mktime() 函数来转换 import time year = int(input(\"请输入年份：\")) month = int(input(\"请输入月份：\")) day = int(input(\"请输入日期：\")) hour = int(input(\"请输入小时：\")) tuple_time = time.strptime(\"%d-%d-%d\" % (year, month, day), \"%Y-%m-%d\") timestamp = time.mktime(tuple_time) print(timestamp) 执行结果： 请输入年份：2020 请输入月份：1 请输入日期：1 请输入小时：12 1577851200.0 获取某月日历 Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历： import calendar cal = calendar.month(2020, 1) print(\"以下输出2020年1月份的日历:\") print(cal) 执行结果： 以下输出2020年1月份的日历: January 2020 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 参考文档： 1. https://www.runoob.com/python/python-date-time.html Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:11:29 "},"chapter02/":{"url":"chapter02/","title":"数据基本运算","keywords":"","body":"数据基本类型 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-29 13:55:49 "},"chapter02/bianliang.html":{"url":"chapter02/bianliang.html","title":"变量","keywords":"","body":"变量 1.定义：关联一个对象的标识符。 2.命名：必须是字母或下划线开头，后跟字母、数字、下划线。 不能使用关键字(蓝色)，否则发生语法错误：SyntaxError: invalid syntax。 3.建议命名：字母小写，多个单词以下划线隔开。 class_name 4.赋值：创建一个变量或改变一个变量关联的数据。 5.语法：变量名 = 数据 变量名1 = 变量名2 = 数据 变量名1, 变量名2, = 数据1, 数据2 例如： x = y = 2 x,y = 3,4 更多详细说明，可查看【 Python简介 --- > 赋值 】 说 明 变量名只能包含字母、数字和下划线。 变量名可以字母或下划线打头，但不能是数字打头。 例如变量命message_1。但是不能写成1_message。 变量交换 a = input(\"请输入第一个变量：\") b = input(\"请输入第二个变量：\") # 版本1 所有语言通用思维 # temp = a # a = b # b = temp # 版本2 数据交换 python a, b = b, a print(\"第一个变量是：\" + a) print(\"第二个变量是：\" + b) 内存图 语义：内存图 变量名：真实内存地址的别名 见名知意 赋值号：将右边对象的地址复制给左边内存空间。 变量内存图 name = \"张无忌\" print(\"name id1\", id(name)) name = \"赵敏\" a01 = a02 = \"周芷若\" b01, b02 = \"苏大强\", \"苏明玉\" print(name) print(\"name id2\", id(name)) print(a01) print(\"a01 id\", id(a01)) print(a02) print(\"a02 id\", id(a02)) print(b01) print(\"b01 id\", id(b01)) print(b02) print(\"b02 id\", id(b02)) 执行结果： name id1 4916968 赵敏 name id2 5411760 周芷若 a01 id 4917136 周芷若 a02 id 4917136 苏大强 b01 id 4917192 苏明玉 b02 id 4917248 变量内存图练习 内存图演示代码 a = 'A' b = 'B' a = b print(a) # B a = 'A' b = 'B' a = b b = 'C' print(a) # B Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:21:23 "},"chapter02/del.html":{"url":"chapter02/del.html","title":"del 语句","keywords":"","body":"del 语句 1.语法: del 变量名1, 变量名2 2.作用： 用于删除变量,同时解除与对象的关联.如果可能则释放对象。 3.自动化内存管理的引用计数： 每个对象记录被变量绑定(引用)的数量,当为0时被销毁。 内存图 演示代码 a = '悟空' b = a c = a del a, b c = None print(c) # None Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 18:46:17 "},"chapter02/hexin.html":{"url":"chapter02/hexin.html","title":"核心数据类型","keywords":"","body":"核心数据类型 1.在python中变量没有类型，但关联的对象有类型。 2.通过type函数可查看。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 11:51:57 "},"chapter02/none.html":{"url":"chapter02/none.html","title":"空值对象 None","keywords":"","body":"空值对象 None 1.表示不存在的特殊对象。 2.作用：占位和解除与对象的关联。 内存图 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 18:22:35 "},"chapter02/int.html":{"url":"chapter02/int.html","title":"整型 int","keywords":"","body":"整形int 1.表示整数，包含正数、负数、0。 如： -5, 100, 0 2.字面值：记住 BOX --- 盒子 前缀 进制 内容 十进制 0 1 2 3 4 5 6 7 8 9 0B 二进制 0 1 0o或0O 八进制 0 1 2 3 4 5 6 7 0x或0X 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f 3.小整数对象池：CPython 中整数 -5 至 256,永远存在小整数对象池中,不会被释放并可重复使用。 【操作】测试不同进制 交互模式下测试 # 十进制 >>> 1212 1212 # 二进制 0 1 >>> 0b101 5 # 八进制 0 1 2 3 4 5 6 7 >>> 0o10 8 >>> 0o19 SyntaxError: invalid syntax # 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f >>> 0xff 255 >>> 0xf 15 >>> 0x10 16 使用 int()实现类型转换： 1、浮点数直接舍去小数部分。如：int(9.9)结果是：9 2、True转为 1，False转为 0。如：int(True)结果是 1 3、字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错。 >>> int(9.9) 9 >>> int(True) 1 >>> int(456.78) 456 >>> int(\"789\") 789 # True 和 False 可以当做 1 和 0 来看待 >>> 1 + True 2 >>> 1 + False 1 >>> # 字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错。 >>> int(\"456abc\") Traceback (most recent call last): File \"\", line 1, in int(\"456abc\") ValueError: invalid literal for int() with base 10: '456abc' >>> int(\"456.78\") Traceback (most recent call last): File \"\", line 1, in int(\"456.78\") ValueError: invalid literal for int() with base 10: '456.78' >>> int(456.78) 自动转型： 整数和浮点数混合运算时，表达式结果自动转型成浮点数。 比如：2+8.0的结果是 10.0 >>> 2 + 8.0 10.0 整数可以有多大？ Python2中，int是 32位，可以存储从-2147483648到 2147483647的整数（约±21亿）。 Long类型是 64位，可以存储：-2^63--2^63-1之间的数值。 Python3中，int可以存储任意大小的整数，long被取消。我们甚至可以存储下面的值： >>> google = 10 ** 100 >>> google 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 # 来个大点的数字 >>> iu = 365 ** 365 >>> iu 172542277632122737559895849663573864796679834378479399385634817858514240233856370518975392307503597487515877554272400423390904724475213129383256571734521752761522455219286852015259932541676633415145198928889049171460058013959635826258985096089864575659239572555437977656787143478438298699575280824310927416454850159603351152612899693013477557148035714888711213466147498555904868837956608249664749375667879921148935088573321372618215318621849420733459386638493237148318471142878922179172279841839305935141525868711922427005987832870174874877655533054449262012317298129711139446233664797105555689165137283519246240241333680255598722713995635104597085572164058200312739732411861803783709234259404090566362871466804004672193360913201281457559983435495027823960494991149952694039470890910615196202167479029642661312025583646565577682535986939170056800966958628105171291336507223938563485237929534987962043590670191406388767063617706298828125 Googol也是 Google最初的名字，这也是 Google最初的含义。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 22:13:24 "},"chapter02/float.html":{"url":"chapter02/float.html","title":"浮点型 float","keywords":"","body":"浮点型 float 1.表示小数，包含正数、负数，0.0)。 2.字面值： 小数：1.0 2.5 科学计数法：e/E (正负号) 指数 1.23e-2 (等同于0.0123) 1.23456e5(等同于123456.0) 这些数字在内存中也是按照科学计数法存储。 >>> 3.14 3.14 >>> 314e-2 3.14 >>> 314E-2 3.14 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 22:15:27 "},"chapter02/str.html":{"url":"chapter02/str.html","title":"字符串 str","keywords":"","body":"字符串str 是用来记录文本信息(文字信息)。 字面值：双引号 演示： str1 = '我是一个字符串1' str2 = \"我是一个字符串2\" str3 = '''我是一个字符串3''' str4 = \"\"\"我是一个字符串4\"\"\" print(str1) print(str2) print(str3) print(str4) 执行结果： 我是一个字符串1 我是一个字符串2 我是一个字符串3 我是一个字符串4 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:15:24 "},"chapter02/complex.html":{"url":"chapter02/complex.html","title":"复数 complex","keywords":"","body":"复数complex 由实部和虚部组成的数字。 虚部是以j或J结尾。 字面值： 1j 1+1j 1-1j 相关题目参考： pass Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 12:05:05 "},"chapter02/bool.html":{"url":"chapter02/bool.html","title":"布尔 bool","keywords":"","body":"布尔 bool 用来表示真和假的类型 关键字 说明 本质 True 表示真(条件满足或成立) 1 False 表示假(条件不满足或不成立) 0 Python2中没有布尔值，直接用数字 0表示 False,用数字 1表示 True。 Python3中，把 True和 False定义成了关键字，但他们的本质还是 1和 0，甚至可以和数字相加。 【操作】源代码： # bool 类型 # 取值：(真，对的，满足条件)True (假，错的，不满足条件)False # 命题:带有判断性的陈述句。 # 例如：我是个男人。 # 1 > 2 --> False print(1 > 2) 检查是不是偶数 这个功能主要展示的不是快速判断是不是偶数,而是bool判断的用法.因为10可以被2整除,所以余数为0,因此它是==0的,如果换成is_even(3)那就返回False了。 def is_even(num): return num % 2 == 0 is_even(10) # True Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:25:13 "},"chapter02/zhuanhuan.html":{"url":"chapter02/zhuanhuan.html","title":"数据类型转换","keywords":"","body":"数据类型转换和四舍五入 目标 了解类型转换的作用 掌握常用的类型转换 常用的数据类型转换 函数 说明 int(x [,base ]) 转换为整形 float(x ) 转换为浮点 str(x ) 转换为字符串 bool(x ) 转换为布尔 complex(real [,imag ]) 创建一个复数 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 结果为False：bool(0) bool(0.0) bool(None) 1.混合类型自动升级： 整数和浮点数混合运算时，表达式结果自动转型成浮点数。比如：2+8.0的结果是 10.0 1 + 2.14 返回的结果是 3.14 1 + 3.0 返回结果是: 4.0 round(value)可以返回四舍五入的值 【注：但不会改变原有值，而是产生新的值】 内存图示： 操作源码： # int()值使用 float()将其转化成浮点数 >>> float(456) 456.0 # 整数和浮点数混合运算时，表达式结果自动转型成浮点数 >>> 5 + 5.0 10.0 # round(value)可以返回四舍五入的值 >>> c = round(456.78) >>> c 457 >>> round(123.45) 123 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 22:06:02 "},"chapter02/article1111111.html":{"url":"chapter02/article1111111.html","title":"运算符","keywords":"","body":"运算符 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 22:50:34 "},"chapter02/suanshu.html":{"url":"chapter02/suanshu.html","title":"算术运算符","keywords":"","body":"基本算术运算符 运算符 说明 示例 结果 + 加法 2 + 2 4 - 减法 30 - 5 25 * 乘法 2 * 4 8 / 除法：结果为浮点数 8 / 2 4.0 // 地板除：除的结果去掉小数部分 7 // 2 3 % 求余 7 // 2 1 ** 幂运算 2 ** 3 8 优先级从高到低： () ** * / % // + - ▲：除数为0.会产生异常： >>> 3 / 0 Traceback (most recent call last): File \"\", line 1, in 3 / 0 ZeroDivisionError: division by zero 零分割错误：被零分割 ▲：使用 divmod() 函数同时得到商和余数： >>> divmod(13, 3) (4, 1) divmod()是一个函数，它返回的是一个元组； 下面的代码是以我目前会的知识做出来和divmod()函数功能差不多的函数，可以得出相同的结果 def cdmod1(a, b): c = a // b # 取商 d = a % b # 取余数 return (c, d) # 返回一个元组 print(cdmod1(13, 3))# (4, 1) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 22:03:40 "},"chapter02/zengqiang.html":{"url":"chapter02/zengqiang.html","title":"增强运算符","keywords":"","body":"增强运算符 运算符 例子 等价 += y += x 等同于 y = y + x -= y -= x 等同于 y = y - x *= y *= x 等同于 y = y * x /= y /= x 等同于 y = y / x //= y //= x 等同于 y = y // x %= y %= x 等同于 y = y % x **= y **= x 等同于 y = y ** x 注意：“ += ” 中间不能加空格！ 【操作】源代码： >>> a = 2 >>> a += 2 >>> a 4 >>> a -= 2 >>> a 2 >>> a *= 2 >>> a 4 >>> a /= 2 >>> a 2.0 >>> b = 5 >>> b //= 2 >>> b 2 >>> b **= 2 >>> b 4 >>> b %= 2 >>> b 0 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 22:34:05 "},"chapter02/bijiao.html":{"url":"chapter02/bijiao.html","title":"比较运算符","keywords":"","body":"比较运算符 返回布尔类型的值 比较运算的数学表示方式:0 运算符 描述 实例 == 等于 比较对象的值是否相等 (a == b) 返回 False != 不等于 比较两个对象的值是否不相等 (a != b) 返回 True > 大于 返回 x 是否大于 y (a > b) 返回 False 小于 返回 x 是否小于 y (a >= 大于等于 返回 x 是否大于等于 y (a >= b) 返回 False 小于等于 返回 x 是否小于等于 y (a 【操作】源代码： >>> a,b = 15,30 >>> a == b False >>> a != b True >>> a > b False >>> a >> a >= b False >>> a Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 23:29:02 "},"chapter02/luoji.html":{"url":"chapter02/luoji.html","title":"逻辑运算符","keywords":"","body":"逻辑运算符 与and 一假俱假,表示并且(都得满足)的关系。 示例: print(True and True) # True　都得满足条件，结论才满足条件。 print(False and True) # False print(True and False) # False print(False and False) # False 或 or 一真俱真,表示或者(一个满足就行)的关系 示例: print(True or True) # True print(False or True) # True print(True or False) # True print(False or False) # False 非 not 表示取反 例如： print(not True) # 返回False print(not False) # 返回True 短路运算 一但结果确定，后面的语句将不再执行。 练习： # 练习：判断年份是否为闰年。 # 闰年True:年份能被4整除，但是不能被100整除。能被400整除 # 平年 False year = int(input(\"请输入年份：\")) result = year % 4 == 0 and year % 100 != 0 or year % 400 == 0 print(result) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:29:04 "},"chapter02/shenfen.html":{"url":"chapter02/shenfen.html","title":"身份运算符","keywords":"","body":"身份运算符 语法: x is y x is not y 作用： is 用于判断两个对象是否是同一个对象,是时返回True,否则返回False。 is not 的作用与is相反 演示： a = 800 b = 1000 # id函数，可以获取变量存储的对象地址。 print(id(a)) print(id(b)) # flase print(a is b) # is 的本质就是通过ｉｄ函数进行判断的 c = a print(id(c)) print(c is a) d = 1000 print(d is b) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:31:39 "},"chapter02/yunsuanfu.html":{"url":"chapter02/yunsuanfu.html","title":"运算符优先级","keywords":"","body":"优先级 高到低： 算数运算符 比较运算符 快捷运算符 身份运算符 逻辑运算符 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 13:03:17 "},"chapter03/":{"url":"chapter03/","title":"语句","keywords":"","body":"Chapter02 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 21:50:18 "},"chapter03/row.html":{"url":"chapter03/row.html","title":"行","keywords":"","body":"行 1.物理行：程序员编写代码的行。 2.逻辑行：python解释器需要执行的指令。 3.建议一个逻辑行在一个物理行上。 4.如果一个物理行中使用多个逻辑行，需要使用分号；隔开。 5.如果逻辑行过长，可以使用隐式换行或显式换行。 1. 隐式换行：所有括号的内容换行,称为隐式换行 括号包括: () [] {} 三种 2. 显式换行：通过折行符 \\ (反斜杠)换行，必须放在一行的末尾，目的是告诉解释器,下一行也是本行的语句。 图形演示： 代码： # 三个物理行，三个逻辑行 a = 1 b = a + 2 c = a + b # 一个物理行，三个逻辑行（不建议） a = 1;b = a + 2;c = a + b # 一个物理行，一个逻辑行 d = 1 + 2 +3 + 4 # 一个物理行，两个逻辑行 # \\ 表示折行符 e = 1 + 2 \\ +3 + 4 # 四个物理行，一个逻辑行 f = (1 + 2 + 3 + 4) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:34:35 "},"chapter03/pass.html":{"url":"chapter03/pass.html","title":"pass 语句","keywords":"","body":"pass 语句 Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。 Python 语言 pass 语句语法格式如下： pass 实例测试： #!/usr/bin/python # -*- coding: UTF-8 -*- # 输出 Python 的每个字母 for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letter print \"Good bye!\" # 以上实例执行结果： \"\"\" 当前字母 : P 当前字母 : y 当前字母 : t 这是 pass 块 当前字母 : h 当前字母 : o 当前字母 : n Good bye! \"\"\" 笔记： pass 一般用于占位置。 在 Python 中有时候会看到一个 def 函数: def sample(n_samples): pass 该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。 本文内容来源于：https://www.runoob.com/python/python-pass-statement.html 2019-11-06 22:53 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 13:04:40 "},"chapter03/if.html":{"url":"chapter03/if.html","title":"if elif else 语句","keywords":"","body":"If elif else 语句 / 选择结构 1.作用: 让程序根据条件选择性的执行语句。 2.语法: if 条件1: 语句块1 elif 条件2: 语句块2 else: 语句块3 3.说明: elif 子句可以有0个或多个。 else 子句可以有0个或1个，且只能放在if语句的最后。 选择结构通过判断条件是否成立，来决定执行哪个分支。 选择结构有很多种形式，分为：单分支、双分支、多分支。 演示： sex = input(\"请输入性别：\") if sex == \"男\": print(\"您好，先生！\") elif sex == \"女\": print(\"您好，女士！\") else: print(\"性别未知\") print(\"后续逻辑\") # 调试：让程序中断，逐语句执行。 # 　--　目的：审查程序运行时变量取值 # 审查程序运行的流程 # --　步骤： # 1. 加断点(可能出错的行) # 2. 调试运行 Ｓｈｉｆｔ＋Ｆ９ # 3. 执行一行　F8 # 4. 停止　Ctrl +F2 单分支选择结构 if 语句单分支结构的语法形式如下： if 条件表达式： 语句/语句块 # --------------------------------- if 条件表达式： 语句/语句块 if 条件表达式： 语句/语句块 其中： 条件表达式：可以是逻辑表达式、关系表达式、算术表达式等等。 语句/语句块：可以是一条语句，也可以是多条语句。多条语句，缩进必须对齐一致。 图： if 嵌套 目标：掌握 if 嵌套的执行过程 通过学习if的基本用法，已经知道了 当需要满足条件去做事情的这种情况需要使用if 当满足条件时做事情A，不满足条件做事情B的这种情况使用if- 想一想： 坐火车或者地铁的实际情况是：先进行安检如果安检通过才会判断是否有车票，或者是先检查是否有车票之后才会进行安检，即实际的情况某个判断是再另外一个判断成立的基础上进行的，这样的情况该怎样解决呢？ 答： if嵌套 if嵌套的格式 if 条件1: 满足条件1 做的事情1 满足条件1 做的事情2 ...(省略)... if 条件2: 满足条件2 做的事情1 满足条件2 做的事情2 ...(省略)... 说明 外层的if判断，也可以是if-else 内层的if判断，也可以是if-else 根据实际开发的情况，进行选择 if嵌套的应用 chePiao = 1 # 用1代表有车票，0代表没有车票 daoLenght = 9 # 刀子的长度，单位为cm if chePiao == 1: print(\"有车票，可以进站\") if daoLenght _结果1：chePiao = 1;daoLenght = 9 有车票，可以进站 通过安检 终于可以见到Ta了，美滋滋~~~ 结果2：chePiao = 1;daoLenght = 20 有车票，可以进站 没有通过安检 刀子的长度超过规定，等待警察处理... 结果3：chePiao = 0;daoLenght = 9 没有车票，不能进站 亲爱的，那就下次见了，一票难求啊~~~~(>_结果4：chePiao = 0;daoLenght = 20 没有车票，不能进站 亲爱的，那就下次见了，一票难求啊~~~~(>_ 想一想:为什么结果3和结果4相同？？？ 练一练 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:36:30 "},"chapter03/ifelif.html":{"url":"chapter03/ifelif.html","title":"if 真值表达式","keywords":"","body":"if 语句的真值表达式 if 100: print(\"真值\") # 等同于 if bool(100): print(\"真值\") 相关练习 if 'a' Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 23:02:45 "},"chapter03/ifelifelse.html":{"url":"chapter03/ifelifelse.html","title":"if 条件表达式","keywords":"","body":"条件表达式 语法： 变量 = 结果1 if 条件 else 结果2 作用：根据条件(True/False) 来决定返回结果1还是结果2。 在选择和循环结构中，条件表达式的值为False的情况如下： False、0、0.0、空值None、空序列对象（空列表、空元组、空集合、空字典、空字符串）、空range()对象、空迭代对象、 其他情况，均为True。 这么看来，Python所有合法表达式都可以看做条件表达式，甚至包括函数调用的表达式。 演示： # 条件表达式:有选择性的为变量进行赋值 # sex = None # if input(\"请输入性别:\") == \"男\": # sex = 1 # else: # sex = 0 # print(sex) sex = 1 if input(\"请输入性别:\") == \"男\" else 0 print(sex) 【操作】测试各种条件表达式 if 3: # 整数作为条件表达式 print(\"OK\") a = [] # 列表作为表达式，由于为空列表，是False if a: print(\"空列表,False\") s = \"False\" # 非空字符串，是True if s: print(\"非空字符串，是True\") c = 9 if 3 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:41:12 "},"chapter03/if_game.html":{"url":"chapter03/if_game.html","title":"应用:猜拳游戏","keywords":"","body":"应用 目标 综合使用 if 语句的相关知识 猜拳游戏 演示图： 参考代码： # 引入随机数模块 import random player = input('请输入：剪刀(0) 石头(1) 布(2):') player = int(player) computer = random.randint(0, 2) # 用来进行测试 # print('player=%d,computer=%d',(player,computer)) if ((player == 0) and (computer == 2)) or ((player == 1) and (computer == 0)) or ((player == 2) and (computer == 1)): print('获胜，哈哈，你太厉害了') elif player == computer: print('平局，要不再来一局') else: print('输了，不要走，洗洗手接着来，决战到天亮') 猜数字2.0 最多猜３次，如果猜对提示\"猜对了，总共猜了?次\" 如果超过次数，提示\"游戏结束\". 参考代码： import random random_number = random.randint(1, 100) print(random_number) count = 0 while count random_number: print(\"大了\") elif input_number Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:44:59 "},"chapter03/while.html":{"url":"chapter03/while.html","title":"while 语句","keywords":"","body":"while 循环语句 1.作用: 可以让一段代码满足条件，重复执行。 循环结构用来重复执行一条或多条语句。 while循环适合根据条件循环执行 表达这样的逻辑：如果符合条件，则反复执行循环体里的语句。在每次执行完后都会判断一次条件是否为True，如果为True则重复执行循环体里的语句。 2.图示： 3.语法: while 条件: 满足条件执行的语句 else: 不满足条件执行的语句 4.说明: else子句可以省略。 在循环体内用break终止循环时,else子句不执行。 【提醒】循环体里面的语句至少应该包含改变条件表达式的语句，以使循环趋于结束；否则，就会变成一个死循环。 5.演示： # 需求:执行三次 count = 0 while count 6.练习题演示： \"\"\" 练习:在控制台中循环录入商品信息(名称,单价). 如果名称输入空字符,则停止录入. 将所有信息逐行打印出来. \"\"\" dict_commodity_info = {} while True: name = input(\"请输入商品名称：\") if name == \"\": break price = int(input(\"请输入商品单价：\")) dict_commodity_info[name] = price for key,value in dict_commodity_info.items(): print(\"%s商品单价是%d\"%(key,value)) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 18:18:19 "},"chapter03/for.html":{"url":"chapter03/for.html","title":"for 语句","keywords":"","body":"for 循环语句 1.作用: 用来遍历可迭代对象的数据元素。 可迭代对象是指能依次获取数据元素的对象，例如：容器类型。 【重点】 while 循环适合 根据条件 循环执行 for 循环适合 执行预定次数 的循环 2.语法: for 变量列表 in 可迭代对象: 语句块1 else: 语句块2 3.说明: else子句可以省略。 在循环体内用break终止循环时,else子句不执行。 4.for循环嵌套 结论：外层循环执行一次，内层循环执行多次。 外层控制行，内层控制列. Test01: # 外层循环控制行 for r in range(3):# 0 1 2 # 内层循环控制列 for c in range(4):# 0123 0123 0123 print(\"*\",end = \" \") print() \"\"\" *#*#*# *#*#*# *#*#*# *#*#*# \"\"\" Test02: for r in range(4): for c in range(6): if c % 2 ==0: print(\"*\", end = \" \") else: print(\"#\", end = \" \") print() \"\"\" * # * # * # * # * # * # * # * # * # * # * # * # \"\"\" \"\"\" 外层4　　　　内层 * 0 ** 01 *** 012 **** 0123 \"\"\" * ** *** **** 演示： str01 = \"我叫苏大强!\" # item 存储的是字符串中每个字符的地址 for item in str01: print(id(item)) # 需求：折纸１０次 thickness = 0.0001 for item in range(10): thickness*=2 print(thickness) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:10:06 "},"chapter03/range.html":{"url":"chapter03/range.html","title":"range 函数","keywords":"","body":"range 函数 1.作用: 用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)。 range对象是一个迭代器对象，用来产生指定范围的数字序列。 2.语法: range(start, end [, step]) range(开始点，结束点，间隔) 3.说明: 函数返回的可迭代对象可以用for取出其中的元素 生成数值序列从 start 开始到 end 结束（不包含 end结束点）。 若没有填写 start ,则默认从 0 开始。 step 是可选的步长，默认为 1. 演示： # 整数生成器: range(开始值,结束值,间隔) # for + range ：　更善于执行预定次数。 for item in range(5):#01234 print(item) 如下面几种典型示例： for i in range(10) # 产生序列：0 1 2 3 4 5 6 7 8 9 for i in range(3, 10) # 产生序列：3 4 5 6 7 8 9 for i in range(3, 10, 2) # 产生序列：3 5 7 9 # # 累加前几个月天数 total_day = 0 for i in range(month - 1): total_day += day_of_month[i] # 累加当月天数 total_day += day print(\"是这年的第%d天.\" % total_day) # 方法二: # 累加前几个月天数 total_day = sum(day_of_month[:month - 1]) total_day += day print(\"是这年的第%d天.\" % total_day) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 18:14:19 "},"chapter03/youhuajiqiao.html":{"url":"chapter03/youhuajiqiao.html","title":"循环代码优化技巧","keywords":"","body":"循环代码优化技巧 虽然计算机及越来越快，空间也越来越大，我们仍然要在性能问题上“斤斤计较”。 编写循环时，遵守下面三个原则可以大大提高运行效率，避免不必要的低效计算： 尽量减少循环内部不必要的计算； 嵌套循环中，尽量减少内层循环的计算，尽可能向外放； 局部变量查询较快，尽量使用局部变量。 # 循环代码优化测试 import time start = time.time() for i in range(1000): result = [] for m in range(10000): result.append(i * 1000 + m * 100) end = time.time() print(\"耗时：{0}\".format((end - start))) # ----------------------------------------------- start2 = time.time() for i in range(1000): result = [] c = i * 1000 for m in range(10000): result.append(c + (m * 100)) end2 = time.time() print(\"耗时：{0}\".format((end2 - start2))) 其他优化手段： 1、连接多个字符串，使用join()而不使用+； 2、列表进行元素插入或删除，尽量在列表尾部操作。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 13:26:25 "},"chapter03/55555.html":{"url":"chapter03/55555.html","title":"跳转语句","keywords":"","body":"跳转语句 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 15:33:20 "},"chapter03/break.html":{"url":"chapter03/break.html","title":"break 语句","keywords":"","body":"break 语句 理解： 1.跳出循环体，后面的代码不再执行。 2.可以让while语句的else部分不执行。 概念： break语句可用于 while 和 for 循环，用来结束整个循环。 当有嵌套循环时，break语句只能跳出最近一层的循环。 演示： # 录入过程 while True: str_score = input(\"请输入成绩：\") if str_score == '': break list_score.append(int(str_score)) # 输出过程 for item in list_score: print(item) print(\"最高分：\" + str(max(list_score))) print(\"最低分：\" + str(min(list_score))) print(\"平均分：\" + str(sum(list_score) / len(list_score))) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 18:15:29 "},"chapter03/continue.html":{"url":"chapter03/continue.html","title":"continue 语句","keywords":"","body":"continue 语句 跳过本次，继续下次循环。 continue语句用于结束本次循环，继续下一次。 多个循环嵌套时，continue 也是应用于最近的一层循环。 演示： #　累加1--100之间,能被５整除的数字 # sum_value = 0 # for item in range(1,101): # 满足条件则累加 # if item % 5 == 0: # sum_value+=item # print(sum_value) sum_value = 0 for item in range(1,101): # 不满足条件则跳过本次循环,继续下次循环。 if item % 5 != 0: continue sum_value+=item print(sum_value) 【操作】 要求输入员工的薪资，若薪资小于0则重新输入。最后打印出录入员工的数量和薪资明细，以及平均薪资 #-*-coding:utf-8-*- empNum = 0 # 员工数量 salaryNum = 0 # 员工薪资 salarys = [] # 用于存储所有员工工资明细的列表 while True: s = input(\"Please enter the employee's salary (quit by Q or q): \") if s.upper() == 'Q': print(\"Success! Quit!\") break if float(s) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:50:23 "},"chapter03/exercise.html":{"url":"chapter03/exercise.html","title":"相关练习题","keywords":"","body":"相关练习题 凡是计算机能通过的代码都是正确的，区别在于逻辑思维是否和人的思维接近（也就是代码简洁，易理解）。 以下代码仅供参考( 学的深了,可以尝试优化下列代码 ) 练习题：购买商品找零 \"\"\" 需求： 1、录入一个商品的单价 2、录入一个数量 3、计算总金额，以及要找的零钱 4、当钱不够时，需要提示钱不够 最后需要调试，知道程序的执行过程，以及取值 断点需要在可能会出错的地方加 \"\"\" price = float(input(\"请输入商品的单价：\")) number = int(input(\"请输入购买商品的数量：\")) money = int(input(\"请输入您要给的金额：\")) # 金额 amount_money = price * number if money > amount_money: print(\"商品总额为：{0}元，您支付了{1}元，应找您{2}元。欢迎下次光临！\".format(amount_money, money, (money - amount_money))) else: print(\"您给的钱不够，请重新输入！\") 练习题：季节对应月份 \"\"\" 在控制台中获取一个季节 显示季节对应的月份 \"\"\" # 获取季度 # 需要获取的是字符串，所以就不需要类型转换了 quarter = input(\"请输入季节(如：春,夏,秋,冬)：\") # 逻辑判断 if quarter == \"春\": print(\"您输入的季节为{0},对应的月份是1-3月。\".format(quarter)) elif quarter == \"夏\": print(\"您输入的季节为{0},对应的月份是4-6月。\".format(quarter)) elif quarter == \"秋\": print(\"您输入的季节为{0},对应的月份是7-9月。\".format(quarter)) elif quarter == \"冬\": print(\"您输入的季节为{0},对应的月份是10-12月。\".format(quarter)) else: print(\"请输入正确的季节(如：春,夏,秋,冬)。\") # 执行结果 \"\"\" 请输入季节(如：春,夏,秋,冬)：夏 您输入的季节为夏,对应的月份是4-6月。 请输入季节(如：春,夏,秋,冬)：1 请输入正确的季节(如：春,夏,秋,冬)。 \"\"\" 练习题：输入年、月，输出本月有多少天。 # 练习： # 输入年、月，输出本月有多少天。 year = int(input('年:')) month = int(input('月:')) if (month == 1 or month == 3 or month == 5 or month == 7 or month == 8 or month == 10 or month == 12): print('31天') elif (month == 4 or month == 6 or month == 9 or month == 11): print('30天') elif month == 2 and ((year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)): print('29天') else: print('28天') 练习题：简易计算器 \"\"\" 在控制台中获取一个数，及一个运算符，再获取一个数 根据运算符，做运算 要求：如果运算符不是（+ - × /）则提示运算符有误 \"\"\" # 获取第一个数 num01 = float(input(\"请输入第一个数：\")) # 获取第二个数 num02 = float(input(\"请输入第二个数：\")) # 获取的运算符为字符串 operator = input(\"请输入一个运算符(如：+ , - , * , /)：\") # 逻辑运算 if operator == \"+\": print(\"{0} {1} {2} = {3}\".format(num01 ,operator, num02, (num01 + num02))) elif operator == \"-\": print(\"{0} {1} {2} = {3}\".format(num01 ,operator, num02, (num01 - num02))) elif operator == \"*\": print(\"{0} {1} {2} = {3}\".format(num01 ,operator, num02, (num01 * num02))) elif operator == \"/\": print(\"{0} {1} {2} = {3}\".format(num01 ,operator, num02, (num01 / num02))) else: print(\"请输入正确的运算符(如：+ , - , * , /)!!!\") # 执行结果 \"\"\" 请输入第一个数：20 请输入第二个数：30 请输入一个运算符(如：+ , - , * , /)：+ 20.0 + 30.0 = 50.0 请输入第一个数：5 请输入第二个数：6 请输入一个运算符(如：+ , - , * , /)：d 请输入正确的运算符(如：+ , - , * , /)!!! \"\"\" 练习题：比较最大值 \"\"\" 在控制台中分别获取四个数 打印最大的数 \"\"\" # 思路：假设需要获取的四个数是 1 3 5 7 num01 = int(input(\"请输入第1个数：\")) num02 = int(input(\"请输入第2个数：\")) num03 = int(input(\"请输入第3个数：\")) num04 = int(input(\"请输入第4个数：\")) result = num01 if result 练习题：成绩查询 \"\"\" 在控制台录入成绩(0-100) 判断成绩分类（优秀 良好 中等 及格 不及格 输入有误） ★重点：方法有很多种，目前来说，能达到需求即可，至于是否合理及其他逻辑需要后面的知识来填充。 \"\"\" # 获取成绩 # print(\"欢迎来到成绩查询系统，请按照下列格式输入您的成绩。\") # print(\"优秀90+ 良好80+ 中等70+ 及格60+ 不及格60-\") result = float(input(\"请输入您的成绩：\")) # 逻辑 if 90 练习题：获取月份打印天数 \"\"\" 在控制台中获取月份 打印天数 输入有误 1 3 5 7 8 10 12 ---> 31天 4 6 9 11 ---> 30天 2 ---> 28天 \"\"\" # 获取月份 # 不转换就是字符串比较了 month = int(input(\"请输入月份：\")) # 逻辑 if month 12: print(\"输入有误。\") elif month == 2: print(\"28天\") elif month == 4 or month == 6 or month == 9 or month == 11: print(\"30天\") else: print(\"31天\") 练习题：判断整数是奇数还是偶数赋值给变量 \"\"\" 在控制台中获取一个整数 如果是偶数则为变量state赋值“偶数”，如果是奇数则赋值“奇数” \"\"\" number = int(input(\"请输入一个整数：\")) # 中规中矩的写法如下 if number % 2 == 0: state = \"偶数\" else: state = \"奇数\" print(state) # ************************************************************ # 优化写法如下 # 整数中还涉及到0这个数，目前没解决 state =\"偶数\" if number % 2 == 0 else \"奇数\" print(state) 练习题：获取一个年份，判断是否闰年，并给变量赋值 \"\"\" 在控制台中获取一个年份 如果是闰年，则给变量day赋值29，否则赋值28 Day01 - Day02 练习题08 是教大家怎么判断闰年的，可以把代码直接复制过来参考。 \"\"\" year = int(input(\"请输入一个年份：\")) # 代码可读性差，尽管代码很精简 # day = 29 if not year % 4 and year % 100 or not year % 400 else 28 # 建议写的代码 day = 29 if year % 4 == 0 and year % 100 != 0 or year % 400 == 0 else 28 print(day) 练习题：while循环输出季度月份 \"\"\" 在控制台中获取一个季节 显示季节对应的月份 练习题014可以参考 \"\"\" while True: quarter = input(\"请输入季节(如：春,夏,秋,冬)：\") # 逻辑判断 if quarter == \"春\": print(\"您输入的季节为{0},对应的月份是1-3月。\".format(quarter)) elif quarter == \"夏\": print(\"您输入的季节为{0},对应的月份是4-6月。\".format(quarter)) elif quarter == \"秋\": print(\"您输入的季节为{0},对应的月份是7-9月。\".format(quarter)) elif quarter == \"冬\": print(\"您输入的季节为{0},对应的月份是10-12月。\".format(quarter)) else: print(\"请输入正确的季节(如：春,夏,秋,冬)。\") # 退出循环 if input(\"按e键退出,回车键继续。\") == \"e\": break 练习题：while循环计数3个小练习 \"\"\" 使用while循环做 练习1：在控制台中输出 0 1 2 3 4 5 练习2：在控制台中输出 2 3 4 5 6 7 练习3：在控制台中输出 0 2 4 6 \"\"\" # 练习1 # 计数器 count = 0 while count 练习题：获取月份,显示季度 \"\"\" 在控制台中获取月份,显示季度,或者提示月份错误. 方法一： \"\"\" month = int(input(\"请输入月份(1-12)：\")) if month 12: print(\"您输入的月份有误。\") elif month == 1 or month == 2 or month == 3: print(\"春天\") elif month == 4 or month == 5 or month == 6: print(\"夏天\") elif month == 7 or month == 8 or month == 9: print(\"秋天\") else: print(\"冬天\") # **************************************************** \"\"\" 在控制台中获取月份,显示季度,或者提示月份错误. 方法二： \"\"\" month = int(input(\"请输入月份(1-12)：\")) if month 12: print(\"您输入的月份有误。\") elif month >= 10: print(\"冬天\") elif month >= 7: print(\"秋天\") elif month >= 4: print(\"夏天\") else: print(\"春天\") 练习题：获取年龄打印成年人 \"\"\" 在控制台中获取年龄， 如果小于０岁，打印输入有误 如果一个人的年龄小于2岁，就打印一条消息，指出他是婴儿。 如果一个人的年龄为2（含）～13岁，就打印一条消息，指出他是儿童。 如果一个人的年龄为13（含）～20岁，就打印一条消息，指出他是青少年。 如果一个人的年龄为20（含）～65岁，就打印一条消息，指出他是成年人。 如果一个人的年龄超过65（含）岁～150岁，就打印一条消息，指出他是老年人。 150岁以上，打印\"那不可能\" \"\"\" age = int(input(\"请输入您的年龄：\")) if age > 150: print(\"那不可能\") elif age >= 65: print(\"老年人\") elif age >= 20: print(\"成年人\") elif age >= 13: print(\"青少年\") elif age >= 2: print(\"儿童\") elif age >= 0: print(\"儿童\") else: print(\"输入有误\") 练习题：根据身高体重,参照BMI,返回身体状况 \"\"\" 根据身高体重,参照BMI,返回身体状况. BMI:用体重千克数除以身高米数的平方得出的数字 BMI= weight / height ** 2 中国参考标准 体重过低BMI= 40: print(\"Ⅲ度肥胖BMI≥40.0\") elif bmi >= 30: print(\"II度肥胖30≤BMI= 28: print(\"I度肥胖28≤BMI= 24: print(\"超重24≤BMI= 18.5: print(\"正常范围18.5≤BMI= 0: print(\"体重过低BMI练习题：获取开始结束值打印中间数 \"\"\" 在控制台中获取一个开始值，一个结束值. 如 开始值 3 结束值 10 打印 456789 \"\"\" start_value = int(input(\"请输入一个开始值：\")) end_value = int(input(\"请输入一个结束值：\")) # 计数器 count = start_value + 1 while count 练习题：一张纸对折对少次超珠穆朗玛峰 \"\"\" 一张纸的厚度为0.01毫米 1m =10 分米 = 100 cm = 1000毫米 问对折对少次可超过珠穆朗玛峰 8848.43米 = 8848430毫米 思路 折一次 纸张厚度变化 1 0.01 x 2 = 0.02 2 0.02 x 2 = 0.04 3 0.04 x 2 = 0.08 .... \"\"\" # 计数器 对折次数 count = 1 # 纸张厚度 thickness = 0.01 # while 循环里需要计算单位的一致性，如果改成米的话，则前面输出的厚度会出现科学计数法 while thickness 练习题：猜数字游戏 \"\"\" 猜数字 随机生成一个数 1-100之间 让玩家重复猜测 直到猜对为止 提示 大了 小了 猜对了，总共猜了多少次 \"\"\" # 随机数工具 import random # 生成一个随机数 random_number = random.randint(1,100) # 计数器 count = 0 while True: user_num = int(input(\"请输入你所要猜的数字(范围1-100之间：)\")) count += 1 if user_num random_number: print(\"你猜大了\") else: print(\"恭喜你猜对了！！！\") print(\"您总共猜了{0}次\".format(count)) break 练习题：猜数字游戏2.0 \"\"\" 猜数字 2.0 随机生成一个数 1-100之间 让玩家重复猜测 只能猜测3次 提示 大了 小了 猜对了，总共猜了多少次 猜错了 提示失败 \"\"\" # 随机数工具 import random # 生成一个随机数 random_number = random.randint(1,100) print(random_number) # 计数器 count = 0 while count random_number: print(\"你猜大了\") else: print(\"恭喜你猜对了！！！\") print(\"您总共猜了{0}次\".format(count)) break # 退出循环体，则不会执行下面的else语句了 else: # 3次使用完则执行此段代码，也就是while循环的条件不满足的时候执行 print(\"3次机会已用完，游戏结果！\") 练习题：while根据成绩判断等级2 \"\"\" 循环根据成绩判断等级，如果录入空字符串则退出程序 如果成绩录入次数达到3次，则退出，并提示 成绩错误过多 \"\"\" count = 0 # 逻辑 while count 100: print(\"您输入的成绩错误，请重新输入。\") count += 1 elif score >= 90: print(\"您的成绩为：优秀\") elif score >= 80: print(\"您的成绩为：良好\") elif score >= 70: print(\"您的成绩为：中等\") elif score >= 60: print(\"您的成绩为：及格\") else: print(\"您的成绩为：不及格。\") else: print(\"成绩错误过多。\") 练习题：累加1-100所有数字的和 \"\"\" for 累加1-100所有数字的和 \"\"\" result = 0 for item in range(1,101): result += item print(result) # 5050 练习题：累加1-100所有偶数的和 \"\"\" 累加 1-100 之间偶数之和 \"\"\" # 用于存储累加数的变量 sesult = 0 for item in range(1,101): if item % 2 == 0: # 奇数和 if item % 2 == 1 sesult += item print(sesult) # 2550 奇数 2500 # ****************************************************** # 方法二 sesult1 = 0 for item1 in range(0,101,2): sesult1 += item1 print(item1) print(sesult1) # 偶数 2550 练习题：累加1-100所有奇数的和 \"\"\" 累加 1-100 之间奇数之和 \"\"\" # 用于存储累加数的变量 sesult = 0 for item in range(1,101): if item % 2 == 1: sesult += item print(sesult) # 2500 # ****************************************************** # 方法二 sesult1 = 0 for item1 in range(1,101,2): sesult1 += item1 print(item1) print(sesult1) # 2500 练习题：累加 10-36 之间数之和 \"\"\" 累加 10-36 之间数之和 \"\"\" # 奇数 sesult = 0 for item in range(10,37): sesult += item print(item) # 用于调试看看每次输出的数字是多少 print(sesult) # 621 练习题：while循环做随机数加法考试 \"\"\" 随机数加法考试 随机生成2个随机数 0-10之间 在控制台获取2个数相加的和 如果用户输入正确得10分，错误不得分 总共3道题，最后输出得分 \"\"\" import random # 计数器 count = 0 # 得分 存储 每次答对时累加的分数 score = 0 while count 练习题：for循环做随机数加法考试 \"\"\" 随机数加法考试 随机生成2个随机数 0-10之间 在控制台获取2个数相加的和 如果用户输入正确得10分，错误不得分 总共3道题，最后输出得分 \"\"\" import random count = 0 # 得分 score = 0 for item in range(3): # 生成随机数 random_num01 = random.randint(1,10) random_num02 = random.randint(1,10) count += 1 sum = random_num01 + random_num02 user_value = int(input(\"{0} + {1} = \".format(random_num01, random_num02))) if user_value == sum: print(\"恭喜你答对了+10分\") score += 10 else: print(\"你答错了\") print(\"考试结束,您的总得分为：{0} 分\".format(score)) # 还可以扩展一个根据分数，判断等级的显示。 练习题：判断一个数是否为素数 \"\"\" 在控制台中获取一个整数，判断是否为素数 素数：只能被1和自身整除的整数 思路：排除法，使用2-当前数字之间的整数判断，如果存在被整除则不是素数 2 3 5 7 11 13 17 19 23 \"\"\" # 获取一个整数 num = int(input(\"请输入一个整数：\")) # 没有判断2以下数字 for item in range(2,num): if num % item == 0: print(\"不是素数\") break elif num % (item + 1) == 0: print(\"不是素数\") break else: print(\"是素数\") 练习题：计算 10-50之间 个位不是 2 5 9 的整数之和 \"\"\" 计算 10-50之间 个位不是 2 5 9 的整数之和 \"\"\" sum_value = 0 for item in range(10,51): if item % 10 == 2: # 也可以这样写 item % 10 == 2 or item % 10 == 2 or item % 10 == 2 continue elif item % 10 == 5: continue elif item % 10 == 9: continue sum_value += item print(sum_value) 练习题:字符和编码值互转操作 # 练习1:在控制台中获取一个字符串，循环打印每个字符的编码值 str_value = input(\"请输入一个字符换:\") for item in str_value: print(ord(item)) # 练习2：在控制台中重复录入一个编码值，然后打印字符，如果输入空字符，则退出 while True: str_value = input(\"请输入一个编码值：\") chr_value = int(str_value) if str_value == \"\": break else: print(chr(chr_value)) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 14:05:03 "},"chapter04/":{"url":"chapter04/","title":"索引 index","keywords":"","body":"索引 index 1.作用：访问容器元素 2.语法： 容器[整数] 3.说明： 正向索引从0开始，第二个索引为1，最后一个为len(s)-1。 反向索引从-1开始,-1代表最后一个,-2代表倒数第二个,以此类推,第一个是-len(s)。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:34:47 "},"chapter04/mathematics.html":{"url":"chapter04/mathematics.html","title":"数学运算符","keywords":"","body":"数学运算符 1.+：用于拼接两个容器 2.+=：用原容器与右侧容器拼接,并重新绑定变量 3.*：重复生成容器元素 4.*=：用原容器生成重复元素, 并重新绑定变量 5. >= == !=：依次比较两个容器中元素,一但不同则返回比较结果。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:33:08 "},"chapter04/member.html":{"url":"chapter04/member.html","title":"成员运算符","keywords":"","body":"成员运算符 1.语法： 数据 in 序列 数据 not in 序列 2.作用： 如果在指定的序列中找到值，返回bool类型。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:34:10 "},"chapter04/slice.html":{"url":"chapter04/slice.html","title":"切片 slice","keywords":"","body":"切片 slice 1.作用： 从容器中取出相应的元素重新组成一个容器。 2.语法： 容器[(开始索引):(结束索引)(:(步长))] 3.说明： 小括号()括起的部分代表可省略 结束索引不包含该位置元素 步长是切片每次获取完当前元素后移动的偏移量 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:35:16 "},"chapter04/built_in_function.html":{"url":"chapter04/built_in_function.html","title":"内建函数","keywords":"","body":"内建函数 1.len(x) 返回序列的长度 2.max(x) 返回序列的最大值元素 3.min(x) 返回序列的最小值元素 4.sum(x) 返回序列中所有元素的和(元素必须是数值类型) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 12:35:49 "},"chapter04/str.html":{"url":"chapter04/str.html","title":"字符串 str","keywords":"","body":"字符串str 是用来记录文本信息(文字信息)。 字面值：双引号 网络相关 分割一个字符串为一个列表 这个案例使用换行符分割的,实际应用中,随机应变。 def split_lines(s): return s.split('\\n') split_lines('50\\n python\\n snippets') # ['50', ' python', ' snippets'] 翻转字符串 这个案例告诉我们字符串的翻转用法,相应的简单字符串可以翻转,以后的图片\\音频\\视频,一样可以翻转.如果你在一个函数里用这个功能，可以解决某些场景里的问题。 language = \"sumer-minus\" # SUMER是我公众号，minus是我一个网名 reversed_language = language[::-1] print(reversed_language) # sunim-remus 打印字符串x遍的小函数 从这里提取两个概念:1如何打印n遍,理解函数调用 def repeat(string, n): return (string * n) a=repeat('oop!',10) print(a) >>>oop!oop!oop!oop!oop!oop!oop!oop!oop!oop! 检查一个字符串是否与他的翻转相同 这个小代码把字符串翻转,和bool又一次加深理解 def palindrome(string): return string == string[::-1] print(palindrome('python')) # False 把一个列表拼装成字符串 用到了列表join方法，数据分析中可能用的多的是pandas的DataFrame格式的矩阵、张量，但一维这些东西一样会遇到使用。 strings = ['老虎', '老鼠', '蟑螂'] print('kill'.join(strings)) # 老虎kill老鼠kill蟑螂 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 18:26:24 "},"chapter04/str_code.html":{"url":"chapter04/str_code.html","title":"基础操作","keywords":"","body":"字符串基础操作 定义 由一系列字符组成的不可变序列容器，存储的是字符的编码值。 编码 1.字节byte：计算机最小存储单位，等于8 位bit. 2.字符：单个的数字，文字与符号。 3.字符集(码表)：存储字符与二进制序列的对应关系。 4.编码：将字符转换为对应的二进制序列的过程。 5.解码：将二进制序列转换为对应的字符的过程。 6.编码方式： 编码格式 说明 ASCII 包含英文、数字等字符，每个字符1个字节 GBK 兼容ASCII编码，包含21003个中文；英文1个字节，汉字2个字节 Unicode 国际统一编码，旧字符集每个字符2字节，新字符集4字节 UTF-8 Unicode的存储与传输方式，英文1字节，中文3字节 相关函数 函数 说明 ord(字符串) 返回该字符串的Unicode码 chr(整数) 返回该整数对应的字符串 演示： # 字　－－> 数 num01 = ord(\"a\") print(num01) # 数　－－> 字 str01 = chr(97) print(str01) 执行结果： 97 a Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 23:59:28 "},"chapter04/str_quotation_marks.html":{"url":"chapter04/str_quotation_marks.html","title":"单双三引号区别","keywords":"","body":"单引和双引号的区别 1.单引号内的双引号不算结束符 2.双引号内的单引号不算结束符 演示代码： a = '\"我们一起学Python\"' b = \"'我们一起学Python'\" print(a) print(b) 运行结果： \"我们一起学Python\" '我们一起学Python' 三引号作用 1.换行会自动转换为换行符\\n 2.三引号内可以包含单引号和双引号 演示代码： c = \"\"\" ---------------- 我们一起学Python 共同进步 ---------------- \"\"\" print(c) # ----------------------------- d = \"\"\"我们一起来学Python，\"共同进步\"，'努力前进'\"\"\" print(d) 运行结果： ---------------- 我们一起学Python 共同进步 ---------------- # ----------------------------- 我们一起来学Python，\"共同进步\"，'努力前进' 3.作为文档字符串 def sum(a, b): \"\"\" 求和并返回结果 :param a: 数字1 :param b: 数字2 :return: 运算结果 \"\"\" return a + b print(sum(2, 3)) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 22:21:37 "},"chapter04/str_escape_character.html":{"url":"chapter04/str_escape_character.html","title":"转义字符","keywords":"","body":"转义字符 1.改变字符的原始含义。 字符 含义 \\' 一个单引号 \\\" 一个双引号 \\n 换行 \\t 水平制表符 \\v 垂直制表符 \\a 响铃(BEL) \\b 退格(BS)将当前位置移到前一列 \\r 回车(CR)将当前位置移到本行开头 \\f 换页(FF)将当前位置移动到下页开头 \\\\ 一个反斜杠\\ \\0 空字符 \\? 一个问号 \\ddd 1到3位八进制数所代表的任意字符 \\xhh 十六进制数所代表的任意字符 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\。 演示代码 print('I\\'m ok.') print('I\\'m learning\\nPython.') print('\\\\\\n\\\\') print('\\\\\\t\\\\') print(r'\\\\\\t\\\\') print('''line1 line2 line3''') 运行结果： 2.原始字符串：取消转义。 a = r\"C:\\newfile\\test.py\" print(a) url = \"C:\\\\nltk_data\\\\aodels\\\\bmt15_eval\" # 原始字符串(没有转义符) url = r\"C:\\nltk_data\\aodels\\bmt15_eval\" print(url) 运行结果： C:\\newfile\\test.py Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 00:02:30 "},"chapter04/str_format.html":{"url":"chapter04/str_format.html","title":"字符串格式化","keywords":"","body":"字符串格式化 1.定义： 生成一定格式的字符串。 2.语法： 字符串%(变量) \"我的名字是%s,年龄是%s\" % (name, age) 3.类型码： 类型 说明 %s 字符串 %d 整数 %f 浮点数 演示： # 字符串格式化 a = \"1\" b = \"2\" # \"请输入\" + str(a) + \"+\" + str(b) + \"=?\" # ---------------------------------------------- # 在字符串中插入变量 # 请输入1+2=? # 字符串拼接（缺点：乱） str01 = \"请输入\" + a + \"+\" + b + \"=?\" str02 = \"请输入%s+%s=?\" % (a, b) str03 = \"请输入%s+%.1f=?\" % (\"1\", 10.5678) print(str03) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 00:03:28 "},"chapter04/all_str.html":{"url":"chapter04/all_str.html","title":"字符串通用操作","keywords":"","body":"字符串通用操作 想一想 哪种情况下字符串操作会产生新的对象(id改变) 哪种情况下字符串是在原对象上操作(id不变) 字符串拼接 str01 = \"悟空\" str02 = \"八戒\" # 字符串拼接 str03 = str01 + str02 字符串累加 str01 += str02 print(str01) # 重复生成元素 print(str02 * 3) #八戒八戒八戒 str02 *=3 print(str02) 字符串比较 # 依次比较两个容器中元素,一但不同则返回比较结果。 print(\"a悟空\" > \"b八戒\") 成员运算符 print(\"我叫\" in \"我叫齐天大圣\") 索引 message = \"我叫齐天大圣\" # 获取正数第三个字 print(message[3]) # 获取最后一个字 print(message[-1]) 切片 print(message[0:2])# 我叫 # 开始值默认为开头 print(message[:2])# 我叫 # 结束值默认为末尾 print(message[-2:])# 大圣 print(message[:])#我叫齐天大圣 print(message[-2:-5:-1])#大天齐 print(message[::-1])# 圣大天齐叫我 print(message[1:1])# 空 print(message[3:1])# 空 print(message[-2:1])# 空 # 索引不能越界 # print(message[7]) # 切片越界不报错 print(message[1:7])# 叫齐天大圣 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 00:08:42 "},"chapter04/list_basic_operation.html":{"url":"chapter04/list_basic_operation.html","title":"列表基础操作","keywords":"","body":"定义 由一系列变量组成的可变序列容器。 基础操作 1.创建列表： 列表名 = [] 列表名 = list(可迭代对象) 演示： # 创建空列表 list01 = [] list01 = list() # 创建有默认值列表 list02 = [\"悟空\", 100, True] list02 = list(\"我是齐天大圣\") 执行结果： ['悟空', 100, True] ['我', '是', '齐', '天', '大', '圣'] 2.获取元素 # 索引 print(list02[2]) # 齐 # 切片 print(list02[-4:]) # ['齐', '天', '大', '圣'] 3.添加元素： 列表名.append(元素) 列表.insert(索引，元素) # 追加(在末尾添加) list02.append(\"八戒\") # 插入(在指定位置添加) list02.insert(1, True) # 在索引为１(第二个)的位置添加True 4.定位元素： 目的：可以增删改查元素 索引、切片 # 切片 del list02[1:3] print(list02) # [True, '大', '圣', '八戒'] # [True, 'a', 'b', '八戒'] list02[1:3] = [\"a\", \"b\"] # [True,'八戒'] # list02[1:3] = [] print(list02) 5.遍历列表： 正向： for 变量名 in 列表名: 变量名就是元素 反向： for 索引名 in range(len(列表名)-1,-1,-1): 列表名[索引名]就是元素 演示： # 获取列表中所有元素 for item in list02: print(item) # 倒序获取所有元素 # 不建议 # list02[::-1] 通过切片拿元素，会重新创建新列表. # for item in list02[::-1]: # print(item) # 3 2 1 0 for i in range(len(list02) - 1, -1, -1): print(list02[i]) # -1 -2 -3 -4 for i in range(-1, -len(list02) - 1, -1): print(list02[i]) 6.删除元素： 列表名.remove(元素) del 列表名[索引或切片] # 根据元素删除 list02.remove(\"是\") # 根据位置删除 del list02[0] print(list02) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 10:33:06 "},"chapter04/list_copy.html":{"url":"chapter04/list_copy.html","title":"深拷贝浅拷贝","keywords":"","body":"深拷贝和浅拷贝 浅拷贝：复制过程中,只复制一层变量,不会复制深层变量绑定的对象的复制过程。 深拷贝：复制整个依懒的变量。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 15:54:17 "},"chapter04/list_vs_str.html":{"url":"chapter04/list_vs_str.html","title":"列表VS字符串","keywords":"","body":"列表VS字符串 1.列表和字符串都是序列,元素之间有先后顺序关系。 2.字符串是不可变的序列,列表是可变的序列。 3.字符串中每个元素只能存储字符,而列表可以存储任意类型。 4.列表和字符串都是可迭代对象。 5.函数： 将多个字符串拼接为一个。 result = \"连接符\".join(列表) 将一个字符串拆分为多个。 列表 = “a-b-c-d”.split(“分隔符”) 累加拼接字符串 缺点：每次循环形成（+=）一个新的字符串对象,替换变量引用result。 # 需求：根据ｘｘ逻辑，拼接一个字符串. # \"0123456789\" result = \"\" for item in range(10): #\"\" 每次循环累加的过程演示 #\"0\" #\"01\" #\"012\" result = result + str(item) print(result) # 0123456789 join拼接字符串 优点：每次循环只向列表添加字符串，没有创建列表对象。 # 建个空列表 list_temp = [] # 循环插入 0-9(需要类型转换 str) for item in range(10): list_temp.append(str(item)) # join : list --> str # 拼接列表 没有空格的 result = \"\".join(list_temp) print(type(result)) # print(result) # 0123456789 split 拆分 str01 = \"张无忌-赵敏-周芷若\" list_result = str01.split(\"-\") print(list_result) # ['张无忌', '赵敏', '周芷若'] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 16:34:32 "},"chapter04/list_derivation.html":{"url":"chapter04/list_derivation.html","title":"列表推导式","keywords":"","body":"列表推导式 1.定义： 使用简易方法，将可迭代对象转换为列表。 2.语法： 变量 = [表达式 for 变量 in 可迭代对象] 变量 = [表达式 for 变量 in 可迭代对象 if 条件] 3.说明: 如果if真值表达式的布尔值为False,则可迭代对象生成的数据将被丢弃。 4.演示： 将list01中所有元素,增加１以后存入list02中. list01 = [5, 56, 6, 7, 7, 8, 19] list02 = [] # 正常写法 for item in list01: list02.append(item + 1) # 列表推导式写法 list02 = [item + 1 for item in list01] print(list02) 将list01中大于１０元素,增加１以后存入list02中. list02 = [] # 正常写法 for item in list01: if item > 10: list02.append(item + 1) # 列表推导式写法 list02 = [item + 1 for item in list01 if item > 10] 5.练习题：传统写法 --> 推导式 题目： # 练习:使用range生成1--10之间的数字,将数字的平方存入list01中 # 将list01中所有奇数存入list02 # 将list01中所有偶数存入list03 # 将list01中所有偶数大于5的数字增加1后存入list04 参考推导代码： Test.1 # 传统写法 list01 = [] for item in range(1, 11): list01.append(item ** 2) # 推导式写法 list01 = [item ** 2 for item in range(1, 11)] Test.2 # 传统写法 list02 = [] for item in list01: if item % 2 == 1: list02.append(item) # 推导式写法 list02 = [item for item in list01 if item % 2 == 1] # 换个条件又变成相反的结果 list03 = [item for item in list01 if item % 2 == 0] Test.3 # 传统写法 list04 = [] for item in list01: if item % 2 == 0 and item > 5: list04.append(item + 1) # 推导式写法 list04 = [item + 1 for item in list01 if item % 2 == 0 and item > 5] Test.4 题目：将1970年到2050年中的闰年，存入列表． # 传统写法 list_result = [] for item in range(1970, 2051): if item % 4 == 0 and item % 100 != 0 or item % 400 == 0: list_result.append(item) print(list_result) # 推导式写法 list_result = [item for item in range(1970, 2051) if item % 4 == 0 and item % 100 != 0 or item % 400 == 0] print(list_result) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 19:17:18 "},"chapter04/list_derivation2.html":{"url":"chapter04/list_derivation2.html","title":"列表推导式嵌套","keywords":"","body":"列表推导式嵌套 1.语法： 变量 = [表达式 for 变量1 in 可迭代对象1 for 变量2 in可迭代对象2] 2.传统写法： result = [] for r in [\"a\", \"b\", \"c\"]: for c in [\"A\", \"B\", \"C\"]: result.append(r + c) 3.推导式写法： result = [r + c for r in list01 for c in list02] 4.演示： list01 = [\"a\", \"b\", \"c\"] list02 = [\"A\", \"B\", \"C\"] result = [r + c for r in list01 for c in list02] print(result) # 执行结果 # ['aA', 'aB', 'aC', 'bA', 'bB', 'bC', 'cA', 'cB', 'cC'] 5.列表嵌套字典 [ {\"name\":\"张无忌\",\"age\":28,\"score\":100,\"sex\":\"男\"}, ] 参考代码 list_student_info = [] while True: name = input(\"请输入姓名：\") if name == \"\": break age = int(input(\"请输入年龄：\")) score = int(input(\"请输入成绩：\")) sex = input(\"请输入性别：\") dict_info = {\"name\": name, \"age\": age, \"score\": score, \"sex\": sex} list_student_info.append(dict_info) for dict_info in list_student_info: print(\"%s的年龄是%d,成绩是%d,性别是%s\" % (dict_info[\"name\"], dict_info[\"age\"], dict_info[\"score\"], dict_info[\"sex\"])) # 获取第一个学生信息 dict_info = list_student_info[0] print(\"第一个录入的是：%s,年龄是%d,成绩是%d,性别是%s\" % (dict_info[\"name\"], dict_info[\"age\"], dict_info[\"score\"], dict_info[\"sex\"])) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:29:58 "},"chapter04/list_emory_map.html":{"url":"chapter04/list_emory_map.html","title":"列表内存图","keywords":"","body":"列表原理图(内存图) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 10:44:34 "},"chapter04/list_sort.html":{"url":"chapter04/list_sort.html","title":"列表排序","keywords":"","body":"列表排序(冒泡排序) 列表升序排列 思想 # 列表排序(升序小　--> 大) # [3,80,45,5,7,1] # 目标:列表中所有元素两两比较 # 思想: # 　取出第一个元素,与后面元素进行比较. # 　取出第二个元素,与后面元素进行比较. # 　取出第三个元素,与后面元素进行比较. # ... # 取出倒数第二个元素,与后面元素进行比较. # 如果取出的元素大于(>)后面的元素, # 则交换 思路代码： # 取出第一个元素,与后面元素进行比较 # list01[0] list01[1] # list01[0] list01[2] # list01[0] list01[3] # for c in range(1,len(list01)): # # list01[0] list01[c] # pass # 取出第二个元素,与后面元素进行比较 # for c in range(2,len(list01)): # # list01[1] list01[c] # pass # 取出第三个元素,与后面元素进行比较 # for c in range(3,len(list01)): # # list01[2] list01[c] # pass # 取数据 实现代码： list01 = [3, 81, 3, 5, 81, 5] for r in range(len(list01) - 1): # 作比较 for c in range(r + 1, len(list01)): # list01[2] list01[c] if list01[r] > list01[c]: list01[r], list01[c] = list01[c], list01[r] print(list01) 判断列表中元素是否具有相同的 思路 所有元素俩俩比较,发现相同的则打印结果 所有元素比较结束，都没有发现相同项，则打印结果. 推导过程 # 取出第一个，与后面比较 # list01[0] list01[1] # list01[0] list01[2] # list01[0] list01[3] # for c in range(1,len(list01)): # # list01[0] list01[c] # pass # for c in range(2,len(list01)): # # list01[1] list01[c] # pass # for c in range(3,len(list01)): # # list01[2] list01[c] # pass 实现代码 list01 = [3, 81, 3, 5, 81, 5] # 结果：假设没有相同项 result = False for r in range(0, len(list01) - 1): for c in range(r + 1, len(list01)): if list01[r] == list01[c]: print(\"具有相同项\") result = True break # 退出循环 if result: break if result == False: print(\"没有相同项\") 1 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:47:22 "},"chapter04/tuple_basic_operation.html":{"url":"chapter04/tuple_basic_operation.html","title":"元祖基础操作","keywords":"","body":"元组基础操作 1·定义 1.由一系列变量组成的不可变序列容器。 2.不可变是指一但创建，不可以再添加/删除/修改元素。 2.基础操作 创建空元组 元组名 = () 元组名 = tuple() 创建非空元组 注意：创建只有一个元素的元组时,元素后需要加逗号 , 元组名 = (20,) # 只有一个元素的元组 元组名 = (1, 2, 3) 元组名 = 100,200,300 元组名 = tuple(可迭代对象) 获取元素 ( 根据 索引、切片 ) tuple03 = (\"a\", \"b\", \"c\", \"d\") e01 = tuple03[1] print(type(e01)) # str e02 = tuple03[-2:] print(type(e02)) # tuple 元组属于不可变序列(容器) tuple01 = (1, 2, 3, 4, 5, 6) tuple01[0] = 10 print(tuple01) # 报错信息 # TypeError: 'tuple' object does not support item assignment 可以直接将元组赋值给多个变量 tuper04 = (100, 200) a, b = tuper04 print(a) print(b) 遍历元组： Python 有反向索引 正向： for 变量名 in 列表名: 变量名就是元素 反向： for 索引名 in range(len(列表名)-1,-1,-1): 元祖名[索引名]就是元素 列表转元组 tuple01 = tuple([\"a\", \"b\"]) print(tuple01) 元组转列表 list01 = list(tuple01) print(list01) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 18:37:10 "},"chapter04/tuple_effect.html":{"url":"chapter04/tuple_effect.html","title":"作用","keywords":"","body":"tuple 作用 1.元组与列表都可以存储一系列变量，由于列表会预留内存空间，所以可以增加元素。 2.元组会按需分配内存，所以如果变量数量固定，建议使用元组，因为占用空间更小。 3.应用： 变量交换的本质就是创建元组：x, y = y, x 格式化字符串的本质就是创建元祖：\"姓名:%s, 年龄:%d\" % (\"tarena\", 15) 演示： x = 10 y = 20 x, y = y, x ---> (x,y) = (y,x) print(x,y) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:31:57 "},"chapter04/dict_basic_operation.html":{"url":"chapter04/dict_basic_operation.html","title":"字典基础操作","keywords":"","body":"字典 dict 1.定义 1.由一系列键值对组成的可变映射容器。 2.映射：一对一的对应关系，且每条记录无序。 3.键必须惟一且不可变(字符串/数字/元组)，值没有限制。 2.基础操作 创建空字典 dict01 = {} dict01 = dict() 创建具有默认值的字典 字典名 = {键1：值1，键2：值2} 字典名 = dict (可迭代对象) dict01 = {\"wj\":100,\"zm\":80,\"zr\":90} dict01 = dict([(\"a\",\"b\"),(\"c\",\"d\")]) 获取元素 / 元素查找 ( 根据key查找value ) 变量 = 字典名[键] # 没有键则错误 # 【注意】如果Key不存在，查找时会报错误. dict01 = {\"wj\":100,\"zm\":80,\"zr\":90} print(dict01[\"qtx\"]) # 报错信息： KeyError: 'qtx' #------------------------------------------ # 【推荐】在查找字典时加一个判断 if \"qtx\" in dict01:# 如果存在key,才打印 print(dict01[\"qtx\"]) 添加 / 修改元素 语法: 字典名[键] = 数据 说明: 键不存在，创建记录。 键存在，修改映射关系。 演示： # 修改元素(之前存在key) dict01[\"a\"] = \"BB\" # 添加(之前不存在key) dict01[\"e\"] = \"f\" 删除字典元素 del 字典名[键] dict01 = {'a':1,'b':2,'c':3} del dict01[\"a\"] print(dict01) # 执行结果：{'b': 2, 'c': 3} 遍历字典 语法： for 键名 in 字典名: 字典名[键名] for 键名,值名 in 字典名.items(): 语句 字典如何根据value查找key # 解决方案１:键值互换 dict02 = {value: key for key, value in dict01.items()} print(dict02) print(dict02[101]) # 缺点:如果key重复,交换或则丢失数据。 # 如果需要保持所有数据 # [(k,v),] list02 = [(value, key) for key, value in dict01.items()] print(list02) 演示： dict01 = {'a': 1, 'b': 2, 'c': 3, 'd': 4} # 获取字典的key for key in dict01: print(key) # 获取字典中所有元素 for key in dict01: print(key) print(dict01[key]) # 根据key获取value # 获取字典中所有value for value in dict01.values(): print(value) # ----------------------------------------------- # 获取键值对key value(元组) for item in dict01.items(): print(item) # 执行结果 ('a', 1) ('b', 2) ('c', 3) ('d', 4) # ----------------------------------------------- # 获取到的元组,可以根据元组的特性来取值 # 下面2种方式，更推荐第二种，一目了然 # NO.1 for item in dict01.items(): print(item[0]) print(item[1]) # NO.2 for k,v in dict01.items(): print(k) print(v) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:39:17 "},"chapter04/tuple_derivation.html":{"url":"chapter04/tuple_derivation.html","title":"字典推导式","keywords":"","body":"字典推导式 1.定义： 使用简易方法，将可迭代对象转换为字典。 2.语法: {键:值 for 变量 in 可迭代对象} {键:值 for 变量 in 可迭代对象 if 条件} 3.字典推导式演变 Test.1 # 1 2 3 4 ... 10 -> 平方 # 传统写法 dict01 = {} for item in range(1, 11): dict01[item] = item ** 2 print(dict01) # 推导式: dict02 = {item: item ** 2 for item in range(1, 11)} print(dict02) Test.2 # 只记录大于５的数字 # 传统写法 dict01 = {} for item in range(1, 11): if item > 5: dict01[item] = item ** 2 print(dict01) # 推导式: dict02 = {item: item ** 2 for item in range(1, 11) if item > 5} print(dict02) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:14:24 "},"chapter04/dict_vs_list.html":{"url":"chapter04/dict_vs_list.html","title":"字典VS列表","keywords":"","body":"字典 VS 列表 1.都是可变容器。 2.获取元素方式不同,列表用索引,字典用键。 3.字典的插入,删除,修改的速度快于列表。 4.列表的存储是有序的,字典的存储是无序的。 字典嵌套列表 { \"key\":[list], ... \"key\":[list], } 例如： { \"张三\":['喜欢美女','喜欢吃肉','喜欢不穿衣服'], ... \"王五\":['喜欢牌九','喜欢帮倒忙','喜欢看书'], } 演示： dict_student_info = {} while True: name = input(\"请输入姓名：\") if name == \"\": break age = int(input(\"请输入年龄：\")) score = int(input(\"请输入成绩：\")) sex = input(\"请输入性别：\") dict_student_info[name] = [age, score, sex] # 打印所有学生信息 for name,list_info in dict_student_info.items(): print(\"%s的年龄是%d,成绩是%d,性别是%s\"%(name,list_info[0],list_info[1],list_info[2])) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 18:22:05 "},"chapter04/set_basic_operation.html":{"url":"chapter04/set_basic_operation.html","title":"集合基本操作","keywords":"","body":"集合 set 1.定义 1.由一系列不重复的不可变类型变量组成的可变映射容器。 2.相当于只有键没有值的字典(键则是集合的数据)。 2.基础操作 创建空集合： 集合名 = set() 集合名 = set(可迭代对象) 创建具有默认值集合 集合名 = {1, 2, 3} 集合名 = set(可迭代对象) set --> str set01 = set(\"abcac\") list01 = list(set01) str01 = \"\".join(list01) print(str01) # \"bca\" 3.添加元素： 集合名.add(元素) 4.删除元素： 集合名.discard(元素) 集合名.remove(元素) 演示： set02 = {\"a\", \"b\", \"a\"} set02.remove(\"a\") set02.discard(\"a\") print(set02) 5.获取集合元素 # 获取所有元素 for item in set02: print(item) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:24:05 "},"chapter04/set_arithmetic.html":{"url":"chapter04/set_arithmetic.html","title":"集合运算","keywords":"","body":"集合运算 1.交集&：返回共同元素。 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 & s2 # {2, 3} 2.并集：返回不重复元素 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 | s2 # {1, 2, 3, 4} 3.补集-：返回只属于其中之一的元素 s1 = {1, 2, 3} s2 = {2, 3, 4} s1 - s2 # {1} 属于s1但不属于s2 补集^：返回不同的的元素 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 ^ s2 # {1, 4} 等同于(s1-s2 | s2-s1) 4.子集 5.超集>：判断一个集合是否具有另一个集合的所有元素 s1 = {1, 2, 3} s2 = {2, 3} s2 s2 # True 6.相同或不同==!=：判断集合中的所有元素是否和另一个集合相同。 s1 = {1, 2, 3} s2 = {3, 2, 1} s1 == s2 # True s1 != s2 # False 子集或相同,超集或相同 = 7.演示 set01 = {1, 2, 3} set02 = {2, 3, 4} # 交集 print(set01 & set02) # {2,3} # 并集 print(set01 | set02) # {1, 2, 3, 4} # 补集 print(set01 ^ set02) # {1, 4} print(set01 - set02) # {1} print(set02 - set01) # {4} # 子集 set03 = {1, 2} print(set03 set03) 8.练习 # 练习: 经理：曹操,刘备,孙权 # 技术：曹操,刘备,张飞,关羽 # 请计算： # (1)是经理也是技术的有谁？ # (2)是经理，不是技术的有谁? # (3)是技术，不是经理的有谁? # (4)张飞是经理吗? # (5)身兼一职的都有谁? # (6)经理和技术总共有都少人? set01 = {\"曹操\", \"刘备\", \"孙权\"} set02 = {\"曹操\", \"刘备\", \"张飞\", \"关羽\"} print(set01 & set02) print(set01 - set02) print(set02 - set01) print(\"张飞\" in set01) print(set01 ^ set02) print(len(set01 | set02)) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:44:36 "},"chapter04/set_derivation.html":{"url":"chapter04/set_derivation.html","title":"集合推导式","keywords":"","body":"集合推导式 1.定义： 使用简易方法，将可迭代对象转换为集合。 2.语法: {表达式 for 变量 in 可迭代对象} {表达式 for 变量 in 可迭代对象 if 条件} Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 16:18:27 "},"chapter04/frozenset.html":{"url":"chapter04/frozenset.html","title":"固定集合 frozenset","keywords":"","body":"固定集合 frozenset 1.定义 不可变的集合。 2.作用 固定集合可以作为字典的键,还可以作为集合的值。 3.基础操作 创建固定集合：frozenset(可迭代对象) 4.运算 等同于set 5.演示 set01 = frozenset([1, 2, 3, 3, 5]) list02 = list(set01) print(set01) print(list02) 运行结果： frozenset({1, 2, 3, 5}) [1, 2, 3, 5] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:25:44 "},"chapter04/sequence_summary.html":{"url":"chapter04/sequence_summary.html","title":"容器总结","keywords":"","body":"容器总结 例如：在存储多个学生信息(姓名,年龄,成绩,性别)的多种方式 选择策略：根据具体需求，结合优缺点，综合考虑(两害相权取其轻). 字典： 优点：根据键获取值，读取速度快； 　　　代码可读性相对列表更高(根据键获取与根据索引获取). 缺点：内存占用大； 　　　获取值只能根据键,不灵活. 列表： 优点：根据索引/切片，获取元素更灵活. 相比字典占内存更小。 缺点：通过索引获取，如果信息较多，可读性不高. 演示： 字典内嵌列表: { \"张无忌\":[28,100,\"男\"], } 字典内嵌字典: { \"张无忌\":{\"age\":28,\"score\":100,\"sex\":\"男\"}, } 列表内嵌字典: [ {\"name\":\"张无忌\",\"age\":28,\"score\":100,\"sex\":\"男\"}, ] 列表内嵌列表 [ [\"张无忌\",28,100男], ] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 17:08:02 "},"chapter04/Exercises.html":{"url":"chapter04/Exercises.html","title":"相关练习题","keywords":"","body":"容器相关练习题 练习:在控制台中录入多个人的多个喜好,输入空字符停止. 例如:请输入姓名： 请输入第1个喜好： 请输入第2个喜好： ... 请输入姓名： ... 最后在控制台打印所有人的所有喜好. [ {“无忌”:[赵敏,周芷若,小赵]} ] 参考代码： list_person_bobby = [] while True: name = input(\"请输入姓名：\") if name == \"\": break dict_person = {name:[]} list_person_bobby.append(dict_person) while True: bobby = input(\"请输入喜好：\") if bobby == \"\": break dict_person[name].append(bobby) print(list_person_bobby) 执行结果： [{'张三': ['喜欢美女', '喜欢吃肉']}, {'李四': ['喜欢打架', '喜欢惹事']}, {'王五': ['喜欢牌九']}] 使用 字典嵌套列表的方式 { “无忌”:[赵敏,周芷若,小赵] } \"\"\" dict_person_bobby = {} while True: name = input(\"请输入姓名：\") if name == \"\": break dict_person_bobby[name] = [] while True: bobby = input(\"请输入喜好：\") if bobby == \"\": break dict_person_bobby[name].append(bobby) for name, list_bobby in dict_person_bobby.items(): print(\"%s喜欢：\" % name) for item in list_bobby: print(item) 练习:列表的全排列 # [“香蕉”,\"苹果\",\"哈密瓜\"] # [“可乐”,\"牛奶\"] list01 = [\"香蕉\",\"苹果\",\"哈密瓜\"] list02 = [\"可乐\",\"牛奶\"] # 传统写法 list03 = [] for r in list01: for c in list02: list03.append(r+c) # 推导式写法 list04 = [r+c for r in list01 for c in list02] print(list03) print(list04) Test.1 # 练习1:[\"无忌\",\"赵敏\",\"周芷若\"] # # ->{\"无忌\":2,\"赵敏\":2,\"周芷若\":3} list01 = [\"无忌\", \"赵敏\", \"周芷若\"] dict01 = {} for item in list01: dict01[item] = len(item) dict02 = {item: len(item) for item in list01} print(dict01) print(dict02) Test.2 # 练习2:[\"无忌\",\"赵敏\",\"周芷若\"] [101,102,103] # {\"无忌\":101,\"赵敏\":102,\"周芷若\":103} # 10:18 list01 = [\"无忌\", \"赵敏\", \"周芷若\"] list02 = [101, 101, 103] dict01 = {} # 通过索引同时在多个列表中获取元素 for i in range(len(list01)): # key = list01[i] # value = list02[i] # dict01[key] = value dict01[list01[i]] = list02[i] print(dict01) Test.3 Test.4 Test.5 Test.6 Test.7 Test.1 Test.1 Test.1 Test.1 Test.1 Test.1 Test.1 Test.1 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:36:52 "},"chapter05/":{"url":"chapter05/","title":"函数 Function","keywords":"","body":"定义 1.用于封装一个特定的功能，表示一个功能或者行为。 2.函数是可以重复执行的语句块, 可以重复调用。 函数作用 提高代码的可重用性和可维护性（代码层次结构更清晰）。 定义函数 1.语法： def 函数名(形式参数): 函数体 2.说明： def 关键字：全称是define，意为”定义”。 函数名：对函数体中语句的描述，规则与变量名相同。 形式参数：方法定义者要求调用者提供的信息。 函数体：完成该功能的语句。 3.函数的第一行语句建议使用文档字符串描述函数的功能与参数。 调用函数 1.语法：函数名(实际参数) 2.说明：根据形参传递内容。 4.相关代码演示： # 定义一个函数 def dog(): print(\"小狗\") # 调用函数 dog() # 输出：小狗 # 定义一个带参数的函数 def dog(user): print(\"%s的小狗\" % user) # 调用函数 dog('张三') # 输出结果 张三的小狗 # 练习:将下列代码，定义到函数中，再调用一次. def print_rectangle(r_count, c_count, char): \"\"\" 打印矩形 :param r_count: 行数 :param c_count: 列数 :param char: 填充的字符 \"\"\" for r in range(r_count): # 内层循环控制列 for c in range(c_count): print(char, end=\" \") print() print_rectangle(5, 2, \"#\") Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:34:19 "},"chapter05/return_function.html":{"url":"chapter05/return_function.html","title":"函数的返回值","keywords":"","body":"函数的返回值 1.定义： 方法定义者告诉调用者的结果。 2.语法： return 数据 3.说明： return后没有语句，相当于返回 None。 函数体没有return，相当于返回 None。 4.相关演示代码 \"\"\" 函数返回值 语法 \"\"\" # 参数：调用者传递给定义者的信息 # 返回值：定义者传递给调用者的结果 def fun01(a): print(\"fun01执行喽\") # 作用：1. 返回结果 2.退出方法 return 20 print(\"fun01又执行喽\") # F8 逐过程　（调试时跳过方法） # F7 逐语句 （调试时进入方法） re = fun01(10) print(re) # 无返回值函数 def fun02(a): print(\"fun01执行喽\") # return None re = fun02(100) print(re) \"\"\" 函数返回值　应用 \"\"\" # 设计思想：分而治之 # 干一件事 # 需求：定义两个数字相加的函数 # def add(): # 1. 获取数据 # number01 = int(input(\"请输入第一个数字：\")) # number02 = int(input(\"请输入第二个数字：\")) # 2. 逻辑计算 # result = number01 + number02 # 3. 显示结果 # print(result) # # add() def add(number01, number02): # 逻辑处理 return number01 + number02 # 调用者提供数据 number01 = int(input(\"请输入第一个数字：\")) number02 = int(input(\"请输入第二个数字：\")) result = add(number01, number02) # 调用者负责显示结果 print(\"结果是:\" + str(result)) # 定义 一个函数getrecoder def getrecoder(): name = 'James' age = 32 # 返回两个变量的值 return name, age print(name, age) # #在调用时，使用与返回值对应的两个值来接收 # myname,myage = getrecoder() # #将返回值 打印出来，输出 jame,32 # print(myname,myage) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:42:09 "},"chapter05/bianhua.html":{"url":"chapter05/bianhua.html","title":"可变/不可变类型在传参时的区别","keywords":"","body":"可变／不可变类型在传参时的区别 1.不可变类型参数有: 数值型(整数，浮点数,复数) 布尔值bool None 空值 字符串str 元组tuple 固定集合frozenset 2.可变类型参数有: 列表 list 字典 dict 集合 set 3.传参说明： 不可变类型的数据传参时，函数内部不会改变原数据的值。 可变类型的数据传参时，函数内部可以改变原数据。 4.相关演示代码(※记得调试※) # 如何解释下列程序运行的结果 def extendlist(val, list_target=[]): for i in range(val): list_target.append(i) print(list_target) extendlist(3) # [0, 1, 2] extendlist(3) # [0, 1, 2, 0, 1, 2] list02 = [] extendlist(3, list02) # [0, 1, 2] # 解释 # 解释器会将函数定义到方法区（存储一份），连同默认参数一起创建。 # 所以不指定参数时，使用的就是那一份列表对象。 # 总结：默认参数，不要使用可变参数。 5.类似的面试题 def extendlist(val, list=[]): list.append(val) return list list1 = extendlist(10) list2 = extendlist(123, []) list3 = extendlist('a') print(\"list1 = %s\" % list1) # list1 = [10, 'a'] print(\"list2 = %s\" % list2) # list2 = [123] print(\"list3 = %s\" % list3) # list3 = [10, 'a'] # 上面这段代码的输出结果是什么(2分)？请解释原因(5分)？ Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:37:11 "},"chapter05/argument.html":{"url":"chapter05/argument.html","title":"实参传递方式 argument","keywords":"","body":"实参传递方式argument 1.位置传参 定义：实参与形参的位置依次对应。 def func01(a, b, c): print(a, b, c) func01(1, 2, 3) # 1 2 3 2.序列传参 定义：实参用*将序列拆解后与形参的位置依次对应。 def func02(*args): print(args) func02(1, 2, 3) # (1, 2, 3) def func02(a, b, c, *args): print(a, b, c) print(args) func02(11, 12, 13, 456, 789, 10) # 11 12 13 # (456, 789, 10) 3.关键字传参 定义：实参根据形参的名字进行对应。 def func03(*args,a, b, c): print(a, b, c) print(args) func03(11, 12, 13, a = 456, b = 789, c = 10) # 456 789 10 # (11, 12, 13) 4.字典关键字传参 1.定义：实参用**将字典拆解后与形参的名字进行对应。 2.作用：配合形参的缺省参数，可以使调用者随意传参。 5.演示 def fun01(a, b, c, d): print(a) print(b) print(c) print(d) # 位置实参：实参与形参根据位置进行依次对应. # fun01(1, 2, 3, 4) # 关键字实参:实参与形参根据名称进行对应 # fun01(b=1, d=2, c=3, a=4) # 序列实参:星号将序列拆分后按位置与形参进行对应 # 如果参数很多，可以存储在序列(字符串/列表/元组)中, # 　　再通过*拆分,直接传入函数. # list01 = [\"a\",\"b\",\"c\",\"d\"] # fun01(*list01) # 字典实参:双星号将字典拆分后按名称与形参进行对应 # 如果参数很多，可以存储在字典中, # 　　 再通过**拆分,传入函数. dict01 = {\"a\": 1, \"c\": 3, \"d\": 4, \"b\": 2} fun01(**dict01) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:58:16 "},"chapter05/parameter.html":{"url":"chapter05/parameter.html","title":"形参传递方式 parameter","keywords":"","body":"形参定义方式parameter 1.缺省参数 语法： def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ...): 函数体 说明： 缺省参数必须自右至左依次存在，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数。 缺省参数可以有0个或多个，甚至全部都有缺省参数。 2.位置形参 语法： def 函数名(形参名1, 形参名2, ...): 函数体 3.星号元组形参 语法： def 函数名(*元组形参名): 函数体 作用： 收集多余的位置传参。 说明： 一般命名为'args' 形参列表中最多只能有一个,*args将所有实参合并为一个元组，作用：让实参个数无限。 Exercise: def fun(*args): print(args) fun() fun(1) fun(1,\"2\") fun(*[1,2,3,\"d\"]) fun([1,2,3,\"d\"]) # 定义一个函数，数值相加的函数 # 所以传入多少个实参，都能够计算 def sum_number(*args): result=0 for i in args: result+=i return result result=sum_number(1,2,3,4,5) print(result) 4.命名关键字形参 语法： def 函数名(*, 命名关键字形参1, 命名关键字形参2, ...): 函数体 def 函数名(*args, 命名关键字形参1, 命名关键字形参2, ...): 函数体 作用： 强制实参使用关键字传参 5.双星号字典形参 语法： def 函数名(**字典形参名): 函数体 作用： 收集多余的关键字传参 说明: 一般命名为'kwargs' 形参列表中最多只能有一个 参数自左至右的顺序 位置形参 --> 星号元组形参 --> 命名关键字形参 --> 双星号字典形参 6.演示 # 1. 缺省(默认)形参:如果实参不提供，可以使用默认值. def fun01(a=None, b=0, c=0, d=0): print(a) print(b) print(c) print(d) # 关键字实参 + 缺省形参:调用者可以随意传递参数. # fun01(b=2, c=3) # 2. 位置形参 def fun02(a, b, c, d): print(a) print(b) print(c) print(d) # 3.星号元组形参: * 将所有实参合并为一个元组 # 作用：让实参个数无限 def fun03(*args): print(args) # fun03()# () # fun03(1)# (1,) # fun03(1,\"2\")# (1, '2') # 4.命名关键字形参:在星号元组形参以后的位置形参 # 目的：要求实参必须使用关键字实参. def fun04(a, *args, b): print(a) print(args) print(b) fun04(1, b=2) fun04(1, 2, 3, 4, b=2) def fun05(*, a, b): print(a) print(b) fun05(a=1, b=2) # 5. 双星号字典形参：**目的是将实参合并为字典. # 实参可以传递数量无限的关键字实参. def fun06(**kwargs): print(kwargs) fun06(a=1, b=2) # 作业:调用fun07。 def fun07(a, b, *args, c, d, **kwargs): pass 7.作业:调用fun07 代码 # ｜位置｜｜星号元组｜｜命名关键字｜｜双星号字典｜ def fun07(a, b, *args, c, d, **kwargs): print(a) print(b) print(args) print(c) print(d) print(kwargs) fun07(1, 2, 3, 4, 5, c=6, d=7, e=8, f=9) # 位置实参无限　＋　关键字实参无限 def fun01(*args, **kwargs): print(args) print(kwargs) fun01(1, 2, 3, a=4, c=5) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:21:09 "},"chapter05/func_builtins.html":{"url":"chapter05/func_builtins.html","title":"内建函数","keywords":"","body":"内建函数 数值对象的构造(创建)函数 函数 说明 float(obj) 用字符串或数字转换为浮点数, 如果不给出参数，则返回0.0 int(x, base=10) int(x=0) 用数字或字符串转换为整数,如果不给出参数，则返回0 complex(r=0.0, i=0.0) 用数字创建一个复数(实部为r,虚部为i) bool(x) 用x获取一个布尔值(True/False) 编辑时间：2019.12.31 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 20:20:31 "},"chapter05/neicuntu.html":{"url":"chapter05/neicuntu.html","title":"函数内存图","keywords":"","body":"函数内存图分析 相关代码 及 内存图 # 在方法区中存储函数代码,不执行函数体 def fun01(a): a = 100 num01 = 1 # 因为调用函数，所以开辟一块内存空间，叫做栈帧 # 用于存储在函数内部定义的变量(包含参数). fun01(num01) # 函数执行完毕后，栈帧立即释放(其中定义的变量也会销毁). print(num01) # 1 def fun02(a): # 改变的是传入的可变对象 a[0] = 100 list01 = [1] fun02(list01) print(list01[0]) # 100 def fun03(a): # 改变的是fun03栈帧中变量a的指向 a = 100 list01 = [1] fun03(list01) print(list01[0]) # 1 def fun04(a): a[1] = [200] list01 = [1, [2, 3]] fun04(list01) print(list01[1]) # [200] # 全局变量 g01 = \"ok\" # print(l01) def fun01(): # 局部变量：在函数内部定义的变量 l01 = 100 # print(l01) print(l01) # 　在函数内部可以读取全局变量 # print(g01) # 创建了一个局部变量g01，而不是修改全局变量 # g01 = \"no\" # 定义全局变量g01 global g01 # 此时修改的是全局变量 g01 = \"no\" print(g01) # 定义全局变量g02 global g02 g02 = 250 fun01() print(g01) # ? print(g02) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:55:25 "},"chapter06/legb.html":{"url":"chapter06/legb.html","title":"作用域 LEGB","keywords":"","body":"作用域LEGB 1.作用域：变量起作用的范围。 2.Local局部作用域：函数内部。 3.Enclosing 外部嵌套作用域 ：函数嵌套。 4.Global全局作用域：模块(.py文件)内部。 5.Builtin内置模块作用域：builtins.py文件。 图示： 变量名的查找规则 由内到外：L -> E -> G -> B 如果某个name映射在局部（local）命名空间中没有找到，接下来就会在闭包作用域（enclosed）进行搜索，如果闭包作用域也没有找到，Python就会到全局（global）命名空间中进行查找，最后会在内建（built in）命名空间搜索，如果一个名称在所有命名空间中都没有找到，就会产生一个NameError的错误。 局部变量 1.定义在函数内部的变量(形参也是局部变量) 2.只能在函数内部使用 3.调用函数时才被创建，函数结束后自动销毁 全局变量 1.定义在函数外部,模块内部的变量。 2.在整个模块(py文件)范围内访问（但函数内不能将其直接赋值）。 【操作】测试 str = 'global' def outer(): str = 'outer' def inner(): str = 'inner' print(str) inner() outer() 动画演示图： 【注意】 上面演示的代码中 str 这个变量，其实是Python内部的 str()函数； 如果将代码中的str变量全部注释掉，依然不会报错。 但是如果将 str变量名称变换掉就会报错---> NameError 的错误。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 20:43:44 "},"chapter06/global.html":{"url":"chapter06/global.html","title":"global","keywords":"","body":"global 语句 / 关键字 1.作用： 在函数内部修改全局变量。 在函数内部定义全局变量(全局声明)。 2.语法： global 变量1, 变量2, … 3.说明 在函数内直接为全局变量赋值，视为创建新的局部变量。 不能先声明局部的变量，再用global声明为全局变量 4.相关代码 参考 nonlocal语句.md 内的代码 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 13:57:23 "},"chapter06/nonlocal.html":{"url":"chapter06/nonlocal.html","title":"nonlocal","keywords":"","body":"nonlocal 语句 / 关键字 1.作用： 在内层函数修改外层嵌套函数内的变量 2.语法 nonlocal 变量名1,变量名2, ... 3.说明 在被嵌套的内函数中进行使用 4.演示代码 使用nonlocal声明外层局部变量 # 创建一个函数 def outer(): # 定义一个变量 outB = 10 # 创建一个内部函数 def inner(): print('调用outB = ', outB) # 调用 inner() inner() # 调用 outer() outer() # 调用outB = 10 在嵌套函数内部修改外部函数的局部变量 # 创建一个函数 def outer(): # 定义一个变量 outB = 10 # 创建一个内部函数 def inner(): nonlocal outB # 声明外部函数的局部变量 print('调用outB = ', outB) # 修改变量outB outB = 222 # 调用 inner() inner() # 打印看看 outB 是否被修改 print('outer outB = ', outB) # 调用 outer() outer() # 执行结果 ''' 调用outB = 10 outer outB = 222 ''' 在嵌套函数内部修改全局变量 # 定义一个全局变量 a = 55 # 创建一个函数 def outer(): # 定义一个变量 outB = 10 # 创建一个内部函数 def inner(): nonlocal outB # 声明外部函数的局部变量 print('调用outB = ', outB) # 修改变量outB outB = 222 global a # 声明全局变量 # 修改变量a的值 a = 1000 # 调用 inner() inner() # 打印看看 outB 是否被修改 print('outer outB = ', outB) # 调用 outer() outer() # 打印a 看看 a的值是否被修改 print('a = ', a) # 执行结果 ''' 调用outB = 10 outer outB = 222 a = 1000 ''' 外部嵌套作用域 \"\"\" 外部嵌套作用域 \"\"\" def fun01(): # 是fun01函数的局部作用域 # 也是fun02函数的外部嵌套作用域 a = 1 def fun02(): b = 2 # 可以访问外部嵌套作用域变量 # print(a) # 不能修改外部嵌套作用域变量 # a = 2# 创建了fun02的局部变量 # print(a)# 2 nonlocal a# 声明外部嵌套作用域 a =2 print(a)# 2 fun02() print(a)# 1 fun01() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:50:01 "},"chapter07/":{"url":"chapter07/","title":"面向对象","keywords":"","body":"面向对象复习 类和对象 类和对象 类:抽象　　　向量 class Vector2 str int list 对象:具体　　1,2 Vector2(1,2) \"a\" 1 [1,2] 之间的区别：类与类行为不同 对象与对象数据不同 　 　Vector2(1,2)　Vector2(3,4) 同一个类型的多个对象,数据不同(1,2/3,4),行为(求方向，求大小)相同. 类成员： 实例：对象的数据(变量)，对象的行为(方法). 类:类的数据(变量),类的行为(方法). 可以被所有对象共同操作的数据 静态方法: 实例方法操作实例变量，表示\"个体\"行为. 类方法操作类变量，表示\"大家\"行为. 静态方法不能操作数据，表示为函数都可以. 封装 \"\"\" 封装 数据角度：将多个变量封装到一个自定义类中。 优势： 符合人类的思考方式 可以将数据与对数据的操作封装到一起 功能角度：对外提供必要的功能,隐藏实现的细节. DoubleListHelper.get_elements() -- 私有化：将名称命名为以双下划线开头. 内部修改成员名称 -- 属性：对实例变量的保护(拦截读/写操作) -- __slots__:限定类创建的对象只能有固定的实例变量. 设计角度： 分而治之:将大的需求分解为多个类，每个类负责一个职责。 变则疏之：遇到变化点单独封装为一个类 ------------------ 高内聚：一个类有且只有一个发生变化的原因 低耦合：类与类的关系松散 \"\"\" \"\"\" 复习 面向对象：考虑问题从对象的角度出发. 抽象：从多个事物中，舍弃个别的/非本质的特征(不重要)， 抽出共性的本质(重要的)过程。 三大特征： 封装：将每个变化点单独分解到不同的类中。 例如：老张开车去东北 做法：定义人类，定义车类。 继承：重用现有类的功能和概念，并在此基础上进行扩展。 统一概念 例如：图形管理器，统计圆形/矩形.....面积。 做法：用图形类代表/约束，圆形/矩形..具有计算面积的方法. 多态：调用父\"抽象的\"方法，执行子类\"具体的\"方法. 重写：覆盖父类那个比较抽象的方法。 例如：图形管理器调用图形的计算面积方法 具体图形必须重写图形的计算面积方法。 继承是共性(计算面积)，多态个性(长*宽 / pi *r**2)。 设计原则 开闭原则：允许增加新功能，不允许修改客户端代码. 单一职责：一个有且只有一个改变的原因. 依赖倒置：调用抽象(父)，不要调用具体(子); 抽象不要依赖具体. 组合复用：如果仅仅是代码的复用，优先使用组合. 类与类关系 泛化[继承](做成爸爸) 关联(做成成员变量) 依赖(做成方法参数) \"\"\" 相关演示练习 \"\"\" 请用面向对象思想，描述以下场景： 张无忌　教　赵敏　九阳神功 赵敏　教　张无忌　化妆 张无忌　上班　挣了　10000 赵敏　上班　挣了　6000 体会：对象区分数据的不同 \"\"\" class Person: def __init__(self, name): self.name = name @property def name(self): return self.__name @name.setter def name(self, value): self.__name = value def teach(self, other, skill): print(self.name, \"教\", other.name, skill) def work(self, money): print(self.name, \"上班挣了%d钱\" % money) zwj = Person(\"张无忌\") zm = Person(\"赵敏\") zwj.teach(zm, \"九阳神功\") zm.teach(zwj, \"化妆\") zwj.work(10000) zm.work(6000) \"\"\" 请用面向对象思想，描述以下场景： 玩家(攻击力)攻击敌人(血量)，敌人受伤(掉血)，还可能死亡(掉装备，加分)。 敌人(攻击力)攻击玩家，玩家(血量)受伤(掉血/碎屏),还可能死亡(游戏结束)。 体会：类区别行为的不同 \"\"\" class Player: def __init__(self, hp, atk): self.hp = hp self.atk = atk def attack(self, other): # 打的逻辑 print(\"玩家攻击敌人\") # 通过敌人对象地址，调用实例方法. other.damage(self.atk) def damage(self, value): print(\"玩家受伤\") self.hp -= value if self.hp Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:04:09 "},"chapter07/oosummary.html":{"url":"chapter07/oosummary.html","title":"概述","keywords":"","body":"面向对象 Object Oriented 概述 面向过程 1.分析出解决问题的步骤，然后逐步实现。 例如：婚礼筹办 -- 发请柬（选照片、措词、制作） -- 宴席（场地、找厨师、准备桌椅餐具、计划菜品、购买食材） -- 婚礼仪式（定婚礼仪式流程、请主持人） 2.公式：程序 = 算法 + 数据结构 3.优点：所有环节、细节自己掌控。 4.缺点：考虑所有细节，工作量大。 面向对象 1.找出解决问题的人，然后分配职责。 例如：婚礼筹办 -- 发请柬：找摄影公司（拍照片、制作请柬） -- 宴席：找酒店（告诉对方标准、数量、挑选菜品） -- 婚礼仪式：找婚庆公司（对方提供司仪、制定流程、提供设备、帮助执行） （其实摄影公司、酒店、婚庆公司统统都是对象，那这样下来，我们的大型程序就变成了众多的细小部分，衍生到各个对象，再去着手去写对象中的内容） 2.公式：程序 = 对象 + 交互 3.优点 (1)思想层面： -- 可模拟现实情景，更接近于人类思维。 -- 有利于梳理归纳、分析解决问题。 (2) 技术层面： -- 高复用：对重复的代码进行封装，提高开发效率。 -- 高扩展：增加新的功能，不修改以前的代码。 -- 高维护：代码可读性好，逻辑清晰，结构规整。 想一想 (理解) 下面这个项目能不能正常完成 你是万达的老板，现在要新建一个万达商场，然后招了一百个工人，说明了你是要盖一栋楼，把人往工地上一扔，让工人开始干活。 项目肯定是不能完成的，因为没有分工。工地上可以做的事情很多，可能一件简单又安全的工作同时有多个人去做，而那些复杂又危险的工作，可能到最后都没有人做。 必须要进行分工，哪些人是搭架子，哪些人是负责吊车，哪些人是混水泥。 请数一下下面两个字符串分别有多少个字符 ehihhsqowoqdqiudhoqq ehihh,sqowo,qdqiu,dhoqq 可以看到被分组后的字符串更容易计数 公司里处理的都是大型项目，可能有上万个函数，需要多个程序员合作开发。如果没有分工的话，很可能一个简单的功能，每个程序员都自己写了一个的函数，而特别难的功能没有人愿意去做。 总结：大型的项目，必须要进行分工，将函数分为几个不同的类型，每个人负责一个或多个类型，比如一个人负责网站首页，一个人负责订单界面，一个人负责用户设置页面。 面向过程：根据业务逻辑从上到下写代码 面向对象：将数据与函数绑定到一起，分类进行封装，每个程序员只要负责分配给自己的分类，这样能够更快速的开发程序，减少了重复代码。 面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。 今天我们来学习一种新的编程方式：面向对象编程（Object Oriented Programming，OOP，面向对象程序设计） 解决菜鸟买电脑的问题 第一种方式: 1)在网上查找资料 2)根据自己预算和需求定电脑的型号 MacBook 15 顶配 1W8 3)去市场找到苹果店各种店无法甄别真假 随便找了一家 4)找到业务员,业务员推荐了另外一款 配置更高价格便宜,也是苹果系统的，价格 1W 5)砍价30分钟 付款9999 6)成交 回去之后发现各种问题 第二种方式 : 1)找一个靠谱的电脑高手 2)给钱交易 面向对象和面向过程都是解决问题的一种思路而已 买电脑的第一种方式: 强调的是步骤、过程、每一步都是自己亲自去实现的 这种解决问题的思路我们就叫做面向过程 买电脑的第二种方式: 强调的是电脑高手, 电脑高手是处理这件事的主角,对我们而言,我们并不必亲自实现整个步骤只需要调用电脑高手就可以解决问题 这种解决问题的思路就 是面向对象 用面向对象的思维解决问题的重点 当遇到一个需求的时候不用自己去实现，如果自己一步步实现那就是面向过程 应该找一个专门做这个事的人来做 面向对象是基于面向过程的 解决吃啤酒鸭的问题 第一种方式（面向过程）: 1)养鸭子 2)鸭子长成 3)杀 4)作料 5)烹饪 6)吃 7)卒 第二种方式（面向对象）: 1)找个卖啤酒鸭的人 2)给钱 交易 3)吃 需要了解的定义性文字: 面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体)的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 20:03:47 "},"chapter07/classes_and_objects.html":{"url":"chapter07/classes_and_objects.html","title":"类和对象","keywords":"","body":"类和对象 代码： # 类 class Wife: # 数据成员 def __init__(self,name,sex): # self 是调用当前方法的对象地址 self.name = name self.sex = sex # 行为成员 def play(self): \"\"\" 一起玩耍 \"\"\" print(self.name + \"玩耍\") # 创建对象,实际在调用__init__方法 w01 = Wife(\"莉莉\",\"女\")# 自动将对象地址传入方法 # 调用对象的行为 w01.play()# 自动将对象地址传入方法 总结： 实例方法：操作对象的变量 类方法：操作类的变量 静态方法：即不需要操作实例变量也不需要操作类变量. Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:30:53 "},"chapter07/oo_yufa.html":{"url":"chapter07/oo_yufa.html","title":"OO_语法","keywords":"","body":"语法 定义类 代码 class 类名: \"\"\"文档说明\"\"\" def _init_(self,参数列表): self.实例变量 = 参数 方法成员 说明 -- 类名所有单词首字母大写. -- __init__也叫构造函数，创建对象时被调用，也可以省略。 -- self 变量绑定的是被创建的对象，名称可以随意。 创建对象(实例化) 变量 = 构造函数 (参数列表) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:26:36 "},"chapter07/oo_shilichengyuan.html":{"url":"chapter07/oo_shilichengyuan.html","title":"OO_实例成员","keywords":"","body":"实例成员 实例变量 1.语法 (1)定义：对象.变量名 (2)调用：对象.变量名 2.说明 (1)首次通过对象赋值为创建，再次赋值为修改. w01 = Wife() w01.name = “丽丽” w01.name = “莉莉” (2)通常在构造函数(init)中创建。 w01 = Wife(“丽丽”,24) print(w01.name) (3)每个对象存储一份，通过对象地址访问。 3.作用：描述所有对象的共有数据。 4.dict：对象的属性，用于存储自身实例变量的字典。 实例方法 1.语法 (1) 定义： def 方法名称(self, 参数列表): 方法体 (2) 调用： 对象地址.实例方法名(参数列表) 不建议通过类名访问实例方法 2.说明 (1) 至少有一个形参，第一个参数绑定调用这个方法的对象,一般命名为\"self\"。 (2) 无论创建多少对象，方法只有一份，并且被所有对象共享。 3.作用：表示对象行为。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 13:15:10 "},"chapter07/oo_leichengyuan.html":{"url":"chapter07/oo_leichengyuan.html","title":"OO_类成员","keywords":"","body":"类成员 类变量 1.语法 (1)定义：在类中，方法外定义变量。 class 类名: 变量名 = 表达式 (2)调用： 类名.变量名 不建议通过对象访问类变量 2.说明 -- 存储在类中。 -- 只有一份，被所有对象共享。 3.作用：描述所有对象的共有数据。 类方法 1.语法 (1)定义： @classmethod def 方法名称(cls,参数列表): 方法体 (2)调用： 类名.方法名(参数列表) 不建议通过对象访问类方法 2.说明 -- 至少有一个形参，第一个形参用于绑定类，一般命名为'cls' -- 使用@classmethod修饰的目的是调用类方法时可以隐式传递类。 -- 类方法中不能访问实例成员，实例方法中可以访问类成员。 3.作用：操作类变量。 演示 class Wife: count = 0 @classmethod def print_count(cls): print(\"我有%d房\" % cls.count) def __init__(self,name): self.name = name Wife.count += 1 Wife.print_count() class ICBC: \"\"\" 工商银行 \"\"\" # 表示总行的钱 total_money = 1000000 # 因为类方法没有对象地址self，所以不能访问实例成员 @classmethod def print_total_money(cls): # print(id(cls),id(ICBC)) print(\"总行还剩%d钱\" % ICBC.total_money) def __init__(self, name, money): self.name = name self.money = money # 表示从总行中扣除当前支行使用的金额 ICBC.total_money -= money i01 = ICBC(\"广渠门支行\", 100000) i02 = ICBC(\"陶然亭支行\", 100000) print(\"总行还剩%d钱\" % ICBC.total_money) # 通过类名访问类方法，会将类名传入类方法. ICBC.print_total_money() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:27:42 "},"chapter07/oo_jingtaifangfa.html":{"url":"chapter07/oo_jingtaifangfa.html","title":"OO_静态方法","keywords":"","body":"静态方法 1.语法 (1)定义： @staticmethod def 方法名称(参数列表): 方法体 (2)调用：类名.方法名(参数列表) 不建议通过对象访问静态方法 2.说明 -- 使用@ staticmethod修饰的目的是该方法不需要隐式传参数。 -- 静态方法不能访问实例成员和类成员 3.作用：定义常用的工具函数。 将函数移到类中. 演示 list01 = [ [\"00\", \"01\", \"02\", \"03\"], [\"10\", \"11\", \"12\", \"13\"], [\"20\", \"21\", \"22\", \"23\"], ] class Vector2: \"\"\" 二维向量 可以表示位置/方向 \"\"\" def __init__(self, x, y): self.x = x self.y = y # 函数:表示左边方向 def left(): return Vector2(0, -1) # 函数:表示右边方向 def right(): return Vector2(0, 1) # 作用：位置　＋　方向 pos01 = Vector2(1, 2) l01 = left() pos01.x += l01.x pos01.y += l01.y print(pos01.x, pos01.y) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:30:29 "},"chapter07/encapsulation.html":{"url":"chapter07/encapsulation.html","title":"封装","keywords":"","body":"封装 1.定义 数据角度讲，将一些基本数据类型复合成一个自定义类型。 行为角度讲，向类外提供必要的功能，隐藏实现的细节。 设计角度讲： (1) 分而治之 -- 将一个大的需求分解为许多类，每个类处理一个独立的功能。 -- 拆分好处：便于分工，便于复用，可扩展性强。 (2) 变则疏之 -- 变化的地方独立封装，避免影响其他类。 (3) 高 内 聚 -- 类中各个方法都在完成一项任务(单一职责的类)。 (4) 低 耦 合 -- 类与类的关联性与依赖度要低(每个类独立)，让一个类的改变，尽少影响其他类。 [例如：硬件高度集成化，又要可插拔] 最高的内聚莫过于类中仅包含1个方法，将会导致高内聚高耦合。 最低的耦合莫过于类中包含所有方法，将会导致低耦合低内聚。 2.作用 1.简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。 2.松散耦合，降低了程序各部分之间的依赖性。 数据和操作相关联，方法操作的是自己的数据。 3.私有成员 1.作用：无需向类外提供的成员，可以通过私有化进行屏蔽。 2.做法：命名使用双下划线开头。 3.本质：障眼法，实际也可以访问 实际将变量名改为：_类名__变量名。 私有成员的名称被修改为：类名__成员名，可以通过_dict属性或dir函数查看。 4.__slots__ 作用：限定一个类创建的实例只能有固定的实例变量，不能再额外添加。 语法： # 在类中定义 __slots__ = (“变量名1”,”变量名2”…..) 说明：含有 __slots__ 属性的类所创建的对象没有__dict__ 属性, 即此实例不用字典来存储对象的实例属性。 优点：访止用户因错写属性的名称而发生程序错误。 缺点：丧失了动态语言可以在运行时为对象添加变量的灵活性。 5.属性@property 公开的实例变量，缺少逻辑验证。私有的实例变量与两个公开的方法相结合，又使调用者的操作略显复杂。而属性可以将两个方法的使用方式像操作变量一样方便。 定义： @property def name(self): return self.__name @name.setter def name(self, name): self.__name = name 调用： 对象.属性名 = 数据 变量 = 对象.属性名 说明： -- 通常两个公开的属性，保护一个私有的变量。 -- @property 负责读取，@属性名.setter 负责写入 -- 只写：属性名= property(None, 写入方法名) 演示封装推导过程 NO.1 使用方法，封装变量 class Wife: def __init__(self, name, age, weight): self.name = name # 本质:障眼法(实际将变量名改为：_类名__age) # self.__age = age self.set_age(age) # self.__weight = weight self.set_weight(weight) # 提供公开的读写方法 def get_age(self): return self.__age def set_age(self, value): if 21 NO.2 使用property(读取方法，写入方法)对象,封装变量. class Wife: def __init__(self, name, age, weight): self.name = name # self.set_age(age) self.age = age # self.set_weight(weight) self.weight = weight def get_age(self): return self.__age def set_age(self, value): if 21 NO.3 使用标准属性,封装变量. class Wife: def __init__(self, name, age, weight): self.name = name self.age = age self.weight = weight @property # 创建property对象，只负责拦截读取操作 def age(self): return self.__age @age.setter # 只负责拦截写入操作 def age(self, value): if 21 6.封装设计思想 需求：老张开车去东北 class Person: def __init__(self, name): self.name = name @property def name(self): return self.__name @name.setter def name(self, value): self.__name = value def go_to(self, str_postion, type): \"\"\" 去 :param str_postion: 位置 :param type: 方式 \"\"\" print(self.name, \"去\", str_postion) type.run(str_postion) class Car: def run(self, str_position): \"\"\" 行驶 :param str_position: 位置 \"\"\" print(\"汽车行驶到:\", str_position) lz = Person(\"老张\") car = Car() # 老张开车去东北 lz.go_to(\"东北\", car) 8.向对象的思想描述场景 请以面向对象的思想，描述下列场景: 小明在招商银行取钱 class Person: def __init__(self, name, money): self.name = name self.money = money @property def name(self): return self.__name @name.setter def name(self, value): self.__name = value @property def money(self): return self.__money @money.setter def money(self, value): self.__money = value class Bank: def __init__(self, name, money): self.name = name self.money = money @property def name(self): return self.__name @name.setter def name(self, value): self.__name = value @property def money(self): return self.__money @money.setter def money(self, value): self.__money = value def draw_money(self, person, value): \"\"\" 取钱 :param person: :param value: :return: \"\"\" self.money -= value person.money += value print(person.name, \"取了%d钱\" % value) xm = Person(\"小明\", 0) zsyh = Bank(\"招商\", 100000) zsyh.draw_money(xm, 10000) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:51:47 "},"chapter05/mis.html":{"url":"chapter05/mis.html","title":"案例 信息管理系统","keywords":"","body":"案例 信息管理系统 案例： 需求 实现对学生信息的增加、删除、修改和查询。 分析 界面可能使用控制台，也可能使用Web等等。 1.识别对象：界面视图类 -- 逻辑控制类 -- 数据模型类 2.分配职责： 界面视图类：负责处理界面逻辑，比如显示菜单，获取输入，显示结果等； 逻辑控制类：负责存储学生信息，处理业务逻辑。比如添加、删除等； 数据模型类：定义需要处理的数据类型。比如学生信息。 3.建立交互： 界面视图对象 数据模型对象 逻辑控制对象 设计 数据模型类：StudentModel 数据：编号 id,姓名 name,年龄 age,成绩 score 逻辑控制类：StudentManagerController 数据：学生列表 __stu_list 行为：获取列表 stu_list,添加学生 add_student，删除学生remove_student，修改学生update_student，根据成绩排序order_by_score。 界面视图类：StudentManagerView 数据：逻辑控制对象__manager 行为： ↓ ↓ ↓ ↓ ↓ 显示菜单__display_menu， 选择菜单项__select_menu_item， 入口逻辑main， 输入学生__input_students， 输出学生__output_students， 删除学生__delete_student， 修改学生信息__modify_student， 按成绩输出学生__output_student_by_score 参考代码： 存放在练习项目内 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:52:12 "},"chapter07/inherit.html":{"url":"chapter07/inherit.html","title":"继承","keywords":"","body":"继承 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 14:04:17 "},"chapter07/grammar.html":{"url":"chapter07/grammar.html","title":"语法","keywords":"","body":"继承语法 1.代码 class 子类(父类): def __init__(self,参数列表): super().__init__(参数列表) self.自身实例变量 = 参数 2.说明 -- 子类拥有父类的所有成员。 -- 子类如果没有构造函数，将自动执行父类的，但如果有构造函数将覆盖父类的。 此时必须通过super()函数调用父类的构造函数，以确保父类属性被正常创建。 3.继承-方法 \"\"\" 继承 -- 方法 财产：钱不用孩子挣，但是可以花。 皇位：江山不用孩子打，但是可以坐。 代码：子类不用写，但是可以用。 \"\"\" # 多个子类在概念上一致的，所以就抽象出一个父类. # 多个子类的共性，可以提取到父类中. # 在实际开发过程中： # 从设计角度讲：先有子，再有父. # 从编码角度讲：先有父,再有子. class Person: def say(self): print(\"说话\") class Student(Person): def study(self): print(\"学习\") class Teacher(Person): def teach(self): print(\"讲课\") s01 = Student() # 子类对象可以调用子类成员，也可以调用父类成员. s01.study() s01.say() # 父类成员 p01 = Person() # 父类对象只可以调用父类成员,不能调用子类成员. p01.say() t01 = Teacher() # python 内置函数 # 1. 判断对象是否属于一个类型 # \"老师对象\" 是 一个老师类型 print(isinstance(t01, Teacher)) # True # \"老师对象\" 不是 一个学生类型 print(isinstance(t01, Student)) # Flase # \"老师对象\" 是 一个人类型 print(isinstance(t01, Person)) # True # 2.判断一个类型是否属于另一个类型 # \"老师类型\" 不是 一个学生类型 print(issubclass(Teacher, Student)) # Flase # \"老师类型\" 不是 一个学生类型 print(issubclass(Teacher, Person)) # True # \"人类型\" 不是 一个老师类型 print(issubclass(Person, Teacher)) # Flase 4.继承-变量 内存图 class Person: def __init__(self, name): self.name = name \"\"\" class Student(Person): # 子类若没有构造函数，使用父类的. pass s01 = Student() print(s01.name) \"\"\" class Student(Person): # 子类若具有构造函数，则必须先调用父类构造函数。 def __init__(self, name, score): super().__init__(name) self.score = score p01 = Person(\"李四\") print(p01.name) s01 = Student(\"张三\", 100) print(s01.score) print(s01.name) 5.继承-设计(1) 内存图 # 需求：老张开车去东北 # 变化： 坐飞机 # 坐火车 # 骑车 # ... # 违反了开闭原则： # 如果增加火车，需要增加\"火车类\",再修改人类中的go_to方法. class Person: def __init__(self, name): self.name = name def go_to(self, vehicle, str_position): # 如果是汽车 if type(vehicle) == Car: vehicle.run(str_position) # 否则如果是飞机 elif type(vehicle) == Airplane: vehicle.flay(str_position) class Car: def run(self, str_position): print(\"汽车开到\", str_position) class Airplane: def flay(self, str_position): print(\"飞机飞到\", str_position) p01 = Person(\"老张\") c01 = Car() a01 = Airplane() p01.go_to(c01, \"东北\") p01.go_to(a01, \"东北\") 5.继承-设计(2) 内存图 # 需求：老张开车去东北 # 变化： 坐飞机 # 坐火车 # 骑车 # ... class Vehicle: \"\"\" 交通工具,代表所有具体的交通工具(火车/飞机..) 继承：隔离子类变化,将子类的共性(坐/飞..)提取到父类(运输)中. \"\"\" def transport(self, str_position): # 因为父类太过于抽象，所以写不出方法体. pass # 客户端代码，用交通工具。 class Person: def __init__(self, name): self.name = name def go_to(self, vehicle, str_position): # 多态：调用父，执行子. # 调用的是交通工具的运输方法 # 执行的是飞机的运输方法或者汽车的运输方法 vehicle.transport(str_position) # -------以上是架构师完成的--以下是程序员完成的----- class Car(Vehicle): def transport(self, str_position): print(\"汽车开到\", str_position) class Airplane(Vehicle): def transport(self, str_position): print(\"飞机飞到\", str_position) p01 = Person(\"老张\") c01 = Car() a01 = Airplane() p01.go_to(c01, \"东北\") p01.go_to(a01, \"东北\") Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:44:11 "},"chapter07/multiple_inheritance.html":{"url":"chapter07/multiple_inheritance.html","title":"多继承","keywords":"","body":"多继承 一个子类继承两个或两个以上的基类，父类中的属性和方法同时被子类继承下来。 同名方法的解析顺序（MRO， Method Resolution Order）: 类自身 --> 父类继承列表（由左至右）--> 再上层父类 A / \\ / \\ B C \\ / \\ / D 1.定义 1.重用现有类的功能与概念，并在此基础上进行扩展。 2.说明： -- 子类直接具有父类的成员（共性），还可以扩展新功能。 -- 事物具有一定的层次、渊源，继承可以统一概念。 例如：公司组织架构 老板 行政中心 营销中心 技术中心 人力资源 行政部 销售部 策划部 研发部 产品部 2.优点 1.一种代码复用的方式。 2.以层次化的方式管理类。 3.缺点 耦合度高 4.作用 隔离客户端代码与功能的实现方式。 5.适用性 多个类在概念上是一致的，且需要进行统一的处理。 6.同名方法解析顺序：MRO \"\"\" 多继承 -- 语法 同名方法解析顺序：MRO \"\"\" class A: def m01(self): print(\"A - m01\") class B(A): def m01(self): print(\"B - m01\") class C(A): def m01(self): print(\"C - m01\") class D(B,C): def m02(self): self.m01() d01 = D() d01.m02() print(D.mro())# [D, B,C, A,object] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:59:49 "},"chapter07/related_concepts.html":{"url":"chapter07/related_concepts.html","title":"相关概念","keywords":"","body":"相关概念 父类（基类、超类）、子类（派生类）。 父类相对于子类更抽象，范围更宽泛；子类相对于父类更具体，范围更狭小。 单继承：父类只有一个（例如 Java，C#）。 多继承：父类有多个（例如C++，Python）。 Object类：任何类都直接或间接继承自 object 类。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 14:53:02 "},"chapter07/built-in_function.html":{"url":"chapter07/built-in_function.html","title":"内置函数","keywords":"","body":"内置函数 isinstance(obj, class_or_tuple) 返回这个对象obj 是否是某个类的对象,或者某些类中的一个类的对象。 内存图 演示代码： class Person: def say(self): print(\"说话\") class Student(Person): def study(self): print(\"学习\") class Teacher(Person): def teach(self): print(\"讲课\") s01 = Student() # 子类对象可以调用子类成员，也可以调用父类成员. s01.study() s01.say() # 父类成员 p01 = Person() # 父类对象只可以调用父类成员,不能调用子类成员. p01.say() t01 = Teacher() # python 内置函数 # 1. 判断对象是否属于一个类型 # \"老师对象\" 是 一个老师类型 print(isinstance(t01, Teacher)) # True # \"老师对象\" 不是 一个学生类型 print(isinstance(t01, Student)) # Flase # \"老师对象\" 是 一个人类型 print(isinstance(t01, Person)) # True # 2.判断一个类型是否属于另一个类型 # \"老师类型\" 不是 一个学生类型 print(issubclass(Teacher, Student)) # Flase # \"老师类型\" 不是 一个学生类型 print(issubclass(Teacher, Person)) # True # \"人类型\" 不是 一个老师类型 print(issubclass(Person, Teacher)) # Flase Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:40:19 "},"chapter07/xiangguanexercise.html":{"url":"chapter07/xiangguanexercise.html","title":"相关练习","keywords":"","body":"相关练习题 Exercise-1 \"\"\" 定义父类 动物（行为：叫） 定义子类 狗（行为：跑） 鸟（行为：飞） 创建三个类型的对象 体会：isinstance(对象,类型) 体会：issubclass(类型,类型) \"\"\" class Animal: def shout(self): print(\"喊叫\") class Bird(Animal): def fly(self): print(\"飞\") class Dog(Animal): def run(self): print(\"跑\") animal = Animal() bird = Bird() dog = Dog() print(isinstance(animal, Bird)) print(isinstance(dog, Animal)) print(issubclass(Animal, Bird)) print(issubclass(Dog, Animal)) Exercise-2 \"\"\" 定义父类 车（数据：品牌,速度） 定义子类 电动车（数据：电池容量,充电功率） 创建两个对象 画出内存图. \"\"\" class Car: \"\"\" 车 \"\"\" def __init__(self,brand,speed): self.brand = brand self.speed = speed class Electrocar(Car): \"\"\" 电动车 \"\"\" def __init__(self,brand,speed,battery_capacity,charging_power): super().__init__(brand,speed) self.battery_capacity = battery_capacity self.charging_power = charging_power c01 = Car(\"奔驰\",230) print(c01.brand) e01 = Electrocar(\"比亚迪\",120,15000,220) print(e01.brand) print(e01.charging_power) Exercise-3 \"\"\" 手雷炸了，可能伤害敌人/玩家的生命. 还可能伤害未知事物(鸭子.房子....) 要求：增加了新事物，不影响手雷。 体会：继承的作用 多态的体现 设计原则 开闭原则 单一职责 依赖倒置 画出设计图 \"\"\" class Granade: def __init__(self, atk): self.atk = atk def explode(self, damage_target): # 如果传入的不是子类，则报错. if not isinstance(damage_target, Damageable): raise ValueError(\"不是Damageable的子类\") print(\"爆炸\") # 多态: # 调用父类代表(玩家/敌人.....)的可以受伤者. # 执类行子(具体玩家/敌人.....) damage_target.damage(self.atk) class Damageable: \"\"\" 可以受伤 继承:统一多个子类的概念，隔离变化。 \"\"\" def damage(self, value): # 如果子类不重写，则异常。 raise NotImplementedError() # ------------------------------ class Player(Damageable): def __init__(self, hp): self.hp = hp def damage(self, value): self.hp -= value print(\"玩家受伤啦\") print(\"碎屏\") class Enemy(Damageable): def __init__(self, hp): self.hp = hp def damage2(self, value): self.hp -= value print(\"敌人受伤喽\") print(\"头顶爆字\") g01 = Granade(100) e01 = Enemy(200) p01 = Player(300) g01.explode(p01) Exercise-4 \"\"\" 定义图形管理器类 1. 管理所有图形 2. 提供计算所有图形总面积的方法 具体图形: 圆形(pi × r ** 2) 矩形(长*宽) ... 测试： 创建1个圆形对象，1个矩形对象，添加到图形管理器中. 调用图形管理器的计算面积方法，输出结果。 要求：增加新图形，不修改图形管理器的代码. 体会：面向对象三大特征： 封装/继承/多态 面向对象设计原则： 开闭/单一/倒置 \"\"\" class GraphicManager: def __init__(self): self.__graphics = [] def add_graphic(self, graphic): if isinstance(graphic, Graphic): self.__graphics.append(graphic) else: raise ValueError() def get_total_area(self): total_area = 0 # 遍历图形列表，累加每个图形的面积 for item in self.__graphics: # 多态： # 调用的是图形 # 执行的是圆形/矩形... total_area += item.calculate_area() return total_area class Graphic: def calculate_area(self): # 如果子类不重写，则异常. raise NotImplementedError() #----------------------------------- class Circle(Graphic): def __init__(self,radius): self.radius = radius def calculate_area(self): return 3.14 * self.radius **2 class Rectanlge(Graphic): def __init__(self,length,width): self.lenght = length self.width = width def calculate_area(self): return self.lenght * self.width c01 = Circle(5) r01 = Rectanlge(10,20) manager = GraphicManager() manager.add_graphic(c01) manager.add_graphic(r01) re = manager.get_total_area() print(re) Exercise-5 内存图 \"\"\" 定义员工管理器 1.管理所有员工 2. 计算所有员工工资 员工： 程序员：底薪 + 项目分红 销售：底薪 + 销售额 * 0.05 软件测试... ... 要求：增加新岗位，员工管理器不变. \"\"\" class EmployeeManager: def __init__(self): self.__employees = [] def add_employee(self, emp): self.__employees.append(emp) def get_total_saraly(self): total_saraly = 0 for item in self.__employees: # 调用是抽象的员工类 # 执行是具体的员工(程序员/销售..) total_saraly += item.calculate_salary() return total_saraly class Employee: def __init__(self, base_salary): self.base_salary = base_salary def calculate_salary(self): return self.base_salary # --------------------------------------- class Programmer(Employee): def __init__(self, base_salary, bonus): super().__init__(base_salary) self.bonus = bonus def calculate_salary(self): # return self.base_salary + self.bonus # 扩展重写 return super().calculate_salary()+ self.bonus class Salesmen(Employee): def __init__(self, base_salary, sale_value): super().__init__(base_salary) self.sale_value = sale_value def calculate_salary(self): return self.base_salary + self.sale_value * 0.05 # 测试 manager = EmployeeManager() manager.add_employee(Programmer(200000,500)) manager.add_employee(Salesmen(2000,1000)) print(manager.get_total_saraly()) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:55:02 "},"chapter07/polymorphic.html":{"url":"chapter07/polymorphic.html","title":"多态","keywords":"","body":"多态 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 14:04:18 "},"chapter07/definition_effect.html":{"url":"chapter07/definition_effect.html","title":"定义作用","keywords":"","body":"多态 1.定义 父类的同一种动作或者行为，在不同的子类上有不同的实现。 2.作用 1.继承将相关概念的共性进行抽象，多态在共性的基础上，体现类型的个性化（一个行为有不同的实现）。 2.增强程序扩展性，体现开闭原则。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:50:49 "},"chapter07/rewrite.html":{"url":"chapter07/rewrite.html","title":"重写","keywords":"","body":"重写 子类实现了父类中相同的方法（方法名、参数），在调用该方法时，实际调用的是子类的方法。 1.内置可重写函数 Python中，以双下划线开头、双下划线结尾的是系统定义的成员。我们可以在自定义类中进行重写，从而改变其行为。 __str__函数：将对象转换为字符串(对人友好的) __repr__函数：将对象转换为字符串(解释器可识别的) 2.运算符重载 定义：让自定义的类生成的对象(实例)能够使用运算符进行操作。 演示代码： class Vector1: def __init__(self, x): self.x = x def __str__(self): return \"一维向量的分量是：\" + str(self.x) def __add__(self, other): return Vector1(self.x + other) def __radd__(self, other): return Vector1(self.x + other) def __iadd__(self, other): self.x += other return self v01 = Vector1(10) print(v01 + 2) # v01.__add__(2) # 练习:实现自定义类的对象与数值的减法，乘法运算。 # 略... print(2 + v01) # 练习:实现数值与自定义类的对象的减法，乘法运算。 # 略... print(id(v01)) # 重写__iadd__，实现在原对象基础上的变化。 # 如果重写__iadd__,默认使用__add__，一般会产生新对象. v01 += 2 print(v01,id(v01)) # list01 = [1] # print(id(list01)) # # 生成新对象 # re = list01 + [2] # print(re,id(re)) # # 在原有对象基础上，累加. # list01 += [2] # print(list01,id(list01)) 3.算数运算符 方法名 运算符和表达式 说明 __add__(self,rhs) self + rhs 加法 __sub__(self,rhs) self - rhs 减法 __mul__(self,rhs) self * rhs 乘法 __truediv__(self,rhs) self / rhs 除法 __floordiv__(self,rhs) self // rhs 地板除 __mod__(self,rhs) self % rhs 取模(求余) __pow__(self,rhs) self ** rhs 幂 4.反向算数运算符重载 方法名 运算符和表达式 说明 __radd__(self,lhs) lhs + self 加法 __rsub__(self,lhs) lhs - self 减法 __rmul__(self,lhs) lhs * self 乘法 __rtruediv__(self,lhs) lhs / self 除法 __rfloordiv__(self,lhs) lhs // self 地板除 __rmod__(self,lhs) lhs % self 取模(求余) __rpow__(self,lhs) lhs ** self 幂 5.复合运算符重载 方法名 运算符和表达式 说明 __iadd__(self,rhs) self += rhs 加法 __isub__(self,rhs) self -= rhs 减法 __imul__(self,rhs) self *= rhs 乘法 __itruediv__(self,rhs) self /= rhs 除法 __ifloordiv__(self,rhs) self //= rhs 地板除 __imod__(self,rhs) self %= rhs 取模(求余) __ipow__(self,rhs) self **= rhs 幂 6.比较运算重载 方法名 运算符和表达式 说明 __lt__(self,rhs) self 小于 __le__(self,rhs) self 小于等于 __gt__(self,rhs) self > rhs 大于 __ge__(self,rhs) self >= rhs 大于等于 __eq__(self,rhs) self == rhs 等于 __ne__(self,rhs) self != rhs 不等于 7.演示代码 # 内置可重写函数 class StudentModel: def __init__(self, name=\"\", age=0, score=0, id=0): self.name = name self.age = age self.score = score self.id = id # 对象 --> 字符串 (随意格式) def __str__(self): return \"我叫%s,编号是%d,年龄是%d,成绩是:%d\"%(self.name,self.id,self.age,self.score) # 对象 --> 字符串(解释器可识别,有格式) def __repr__(self): return \"StudentModel('%s',%d,%d,%d)\"%(self.name,self.age,self.score,self.id) s01 = StudentModel(\"无忌\",27,100,101) str01 = str(s01) print(str01) print(s01) str02 =repr(s01) print(str02) # 根据字符串执行python代码 re = eval(\"1+2*5\") # exec print(re) # 克隆对象 # repr 返回python格式的字符串 # eval根据字符串执行代码 s02 = eval(repr(s01)) s02.name = \"老张\" print(s01.name) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:58:33 "},"chapter07/class_to_class_relationship.html":{"url":"chapter07/class_to_class_relationship.html","title":"类与类的关系","keywords":"","body":"类与类的关系 泛化：子类与父类的关系，概念的复用，耦合度最高； B类泛化A类，意味B类是A类的一种； 做法：B类继承A类 关联(聚合/组合)：部分与整体的关系，功能的复用，变化影响一个类； A与B关联，意味着B是A的一部分； 做法：在A类中包含B类型成员。 依赖：合作关系，一种相对松散的协作，变化影响一个方法； A类依赖B类，意味A类的某些功能靠B类实现； 做法：B类型作为A类中方法的参数，并不是A的成员。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 14:04:52 "},"chapter07/Magic_method.html":{"url":"chapter07/Magic_method.html","title":"魔法方法","keywords":"","body":"\"魔法\"方法 打印id() 如果把BMW使用print进行输出的话，会看到如下的信息 # 定义类 class Car: # 移动 def move(self): print('车在奔跑...') # 鸣笛 def toot(self): print(\"车在鸣笛...嘟嘟..\") # 创建一个对象，并用变量BMW来保存它的引用 BMW = Car() BMW.color = '黑色' BMW.wheelNum = 4 #轮子数量 BMW.move() BMW.toot() print(BMW.color) print(BMW.wheelNum) print(BMW) 运行结果： 即看到的是创建出来的BMW对象在内存中的地址 定义__str__()方法 class Car: def __init__(self, newWheelNum, newColor): self.wheelNum = newWheelNum self.color = newColor def __str__(self): msg = \"嘿。。。我的颜色是{0},我有{1}个轮胎...\".format(self.color,int(self.wheelNum)) return msg def move(self): print('车在跑，目标:夏威夷') # 创建一个对象，并用变量BMW来保存它的引用 BMW = Car(4, \"白色\") print(BMW) 运行结果： 嘿。。。我的颜色是白色,我有4个轮胎... 总结 在python中方法名如果是__xxxx__()的，那么就有特殊的功能，因此叫做“魔法”方法 当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 21:20:57 "},"chapter08/":{"url":"chapter08/","title":"设计原则","keywords":"","body":"设计原则 开-闭原则（目标、总的指导思想）Open Closed Principle 对扩展开放，对修改关闭。 增加新功能，不改变原有代码。 类的单一职责（一个类的定义）Single Responsibility Principle 一个类有且只有一个改变它的原因。 依赖倒置（依赖抽象）Dependency Inversion Principle 客户端代码(调用的类)尽量依赖(使用)抽象的组件。 抽象的是稳定的。实现是多变的。 组合复用原则（复用的最佳实践）Composite Reuse Principle 如果仅仅为了代码复用优先选择组合复用，而非继承复用。 组合的耦合性相对继承低。 里氏替换（继承后的重写，指导继承的设计）Liskov Substitution Principle 父类出现的地方可以被子类替换，在替换后依然保持原功能。 子类要拥有父类的所有功能。 子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。 迪米特法则（类与类交互的原则）Law of Demeter 不要和陌生人说话。 类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-29 16:33:56 "},"chapter15/":{"url":"chapter15/","title":"设计模式","keywords":"","body":"Python设计模式 Python一切皆对象 解释：我们用到的每个数字和字符串还是集合还是..本质都有相应的类对应如：name = “axc”可以通过点进行调用：name.strip() 设计模式（Design Patterns）——可复用面向对象软件的基础 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 20:55:12 "},"chapter15/singleton.html":{"url":"chapter15/singleton.html","title":"单例模式(Singleton)","keywords":"","body":"单例模式 1.单例是什么 举个常见的单例模式例子，我们日常使用的电脑上都有一个回收站，在整个操作系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，而且回收站自行提供自己的实例。因此回收站是单例模式的应用。 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。 2.创建单例-保证只有1个对象 # 实例化一个单例 class Singleton(object): __instance = None def __new__(cls, age, name): # 如果类属性__instance的值为None， # 那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时 # 能够知道之前已经创建过对象了，这样就保证了只有1个对象 if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance a = Singleton(18, \"dongGe\") b = Singleton(8, \"dongGe\") print(id(a)) print(id(b)) a.age = 19 # 给a指向的对象添加一个属性 print(b.age) # 获取b指向的对象的age属性 运行结果： 4391023224 4391023224 19 3.创建单例时，只执行1次__init__方法 # 实例化一个单例 class Singleton(object): __instance = None __first_init = False def __new__(cls, age, name): if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instance def __init__(self, age, name): if not self.__first_init: self.age = age self.name = name Singleton.__first_init = True a = Singleton(18, \"dongGe\") b = Singleton(8, \"dongGe\") print(id(a)) print(id(b)) print(a.age) print(b.age) a.age = 19 print(b.age) 运行结果: 95137840 95137840 18 18 19 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 21:24:30 "},"chapter15/iterator.html":{"url":"chapter15/iterator.html","title":"迭代器模式(Iterator)","keywords":"","body":"迭代器模式 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 20:55:47 "},"chapter15/interpreter.html":{"url":"chapter15/interpreter.html","title":"解释器模式(Interpreter)","keywords":"","body":"解释器模式 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 20:55:58 "},"chapter09/":{"url":"chapter09/","title":"模块 Module","keywords":"","body":"案例：项目内各个包内的模块怎么互相调用??? 案例1： \"\"\" 案例： my_ project / main.py common/ __init__.py double_list_helper.py list_helper.py skill_system/ __init__.py skill_deployer.py skill_manager.py 练习: 1.在main.py中调用skill_deployer.py。 2.在skill_deployer.py中调用skill_manager.py。 3.在skill_manager.py中调用double_list_helper.py。 4.在list_helper.py中调用main.py。 要求：在所有的调用过程中，要包含函数、类、实例方法、静态方法。 \"\"\" 参考代码 # main.py 文件内代码 from skill_system.skill_deployer import * class MainTest(object): @staticmethod def print_main(): print(\"print-----MainTest\") # 1.在main.py中调用skill_deployer.py。 s1 = Student(\"张三\", 25) s1.fly() # 张三 25 # ******************************************************************************* # double_list_helper.py 文件内代码 class A(object): def add_a(self): print(\"A --- add_a()\") # ******************************************************************************* # list_helper.py 文件内代码 from main import * class B: @staticmethod def print_B(): print(\"B---print-b\") # 4.在list_helper.py中调用main.py。 # a01 = MainTest() MainTest.print_main() # ******************************************************************************* # skill_deployer.py 文件内代码 from skill_system.skill_manager import * class Student(object): def __init__(self, name, age): self.name = name self.age = age def fly(self): print(self.name, self.age) # 2.在skill_deployer.py中调用skill_manager.py。 re = print_d(5) print(re) # 3125 # ******************************************************************************* # skill_manager.py 文件内代码 from common.double_list_helper import * def print_d(a): return a ** a # 3.在skill_manager.py中调用double_list_helper.py。 s1 = A() s1.add_a() # A --- add_a() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 18:59:55 "},"chapter09/module_01.html":{"url":"chapter09/module_01.html","title":"定义及作用","keywords":"","body":"定义 包含一系列数据、函数、类的文件，通常以.py结尾。 作用 让一些相关的数据，函数，类有逻辑的组织在一起，使逻辑结构更加清晰。 有利于多人合作开发。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 21:25:48 "},"chapter09/module_02.html":{"url":"chapter09/module_02.html","title":"导入","keywords":"","body":"模块导入方法 1. import 模块名 语法： import 模块名 import 模块名 as 别名 作用：将某模块整体导入到当前模块中 使用：模块名.成员 例如：import module1 本质：使用变量名module1关联模块地址 2. from 模块名 import 函数名/类名 语法： from 模块名 import 成员名[ as 别名1] 作用：将模块内的一个或多个成员导入到当前模块的作用域中。 本质：将指定的成员导入到当前模块作用域中 小心：导入进来的成员不要和当前模块成员名称冲突 3. from 模块名 import * 语法： from 模块名 import * 作用：将某模块的所有成员导入到当前模块。 本质：将指定模块的所有成员导入到当前模块作用域中 模块中以下划线（_）开头的属性，不会被导入，通常称这些成员为隐藏成员（仅适用于方式3） 只是在模块内部使用的成员，可以通过单下划线（_）开头 4.导入方式演示 # 导入方式1 # 本质：使用变量名module01关联模块地址 # import module01 # module01.fun01() # my02 = module01.MyClass02() # my02.fun02() # as 为导入的成员其另外一个名称 import module01 as m01 m01.fun01() my02 = m01.MyClass02() my02.fun02() # 导入方式2 # 本质：将指定的成员导入到当前模块作用域中 # 小心：导入进来的成员不要和当前模块成员名称相同 # from module01 import fun01 # from module01 import MyClass02 # # def fun01(): # print(\"当前模块fun01\") # # fun01() # my02 = MyClass02() # my02.fun02() # 导入方式3 # 本质：将指定模块的所有成员导入到当前模块作用域中 # 小心：导入进来的成员和其他模块成员冲突 from module01 import * fun01() my02 = MyClass02() my02.fun02() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:07:07 "},"chapter09/module_03.html":{"url":"chapter09/module_03.html","title":"变量","keywords":"","body":"模块变量 __all__变量：定义可导出成员，仅对from xx import *语句有效。 详解 等待编辑后上传 __doc__变量：文档字符串。 __file__变量：模块对应的文件路径名。 __name__变量：模块自身名字，可以判断是否为主模块。 当此模块作为主模块(第一个运行的模块)运行时，__name__绑定'__main__'，不是主模块，而是被其它模块导入时,存储模块名。 __name__ == \"__main__\":作用： 1、测试代码，只有从当前模块运行才会执行 2、限制只能从当前模块才执行 内置变量 dir():查看某个模块内定义的所有名称，以字符串列表的形式输出。(包括方法成员和数据成员) 在任意一个 .py 文件里执行下列代码 print(dir()) # 执行结果 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'month', 'year'] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 14:24:53 "},"chapter09/module_04.html":{"url":"chapter09/module_04.html","title":"加载过程及分类","keywords":"","body":"加载过程 在模块导入时，模块的所有语句会执行。 如果一个模块已经导入，则再次导入时不会重新执行模块内的语句。 通过导包进入的模块，第一次执行时，会生成pyc模块，在缓存中。 而首先执行的文件不会生成pyc文件，也不会放到缓存中，所以在写代码时，尽量第一个执行的文件当中不要有太多的代码。 分类 1.内置模块(builtins)，在解析器的内部可以直接使用。 2.标准库模块，安装Python时已安装且可直接使用。 3.第三方模块（通常为开源），需要自己安装。 4.用户自己编写的模块（可以作为其他人的第三方模块） 模块能不能导入成功，本质是看导入的内容有没有在搜索路径上 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 14:27:14 "},"chapter09/module_05.html":{"url":"chapter09/module_05.html","title":"搜索顺序","keywords":"","body":"搜索顺序 搜索内建模块(builtins) sys.path 提供的路径，通常第一个是程序运行时的路径。 方法 说明 sys.path 提供的路径，通常第一个是程序运行时的路径。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 21:27:27 "},"chapter09/custom_module.html":{"url":"chapter09/custom_module.html","title":"自定义模块","keywords":"","body":"如何自定义模块 在很多时候，我们可以自己定义属于自己的模块，在日常工作中可以直接拿来使用。 自定义的模块也属于第三方模块。 下面我们就先来看看如何自定义模块 \"\"\" [ [\"00\", \"01\", \"02\", \"03\"], [\"10\", \"11\", \"12\", \"13\"], [\"20\", \"21\", \"22\", \"23\"], ] 在二维列表中，获取13位置，向左，3个元素 在二维列表中，获取22位置，向上，2个元素 在二维列表中，获取03位置，向下，2个元素 \"\"\" class Vector2: \"\"\" 二维向量 可以表示位置/方向 \"\"\" def __init__(self, x, y): self.x = x self.y = y @staticmethod def left(): return Vector2(0, -1) @staticmethod def right(): return Vector2(0, 1) @staticmethod def up(): return Vector2(-1, 0) @staticmethod def down(): return Vector2(1, 0) class DoubleListHelper: @staticmethod def get_elements(target, vect_pos, vect_dir, count): \"\"\" 在二维列表中获取指定位置，指定方向，指定数量的元素. :param target: 二维列表 :param vect_pos: 指定位置 :param vect_dir: 指定方向 :param count: 指定数量 :return: 列表 \"\"\" list_result = [] for i in range(count): vect_pos.x += vect_dir.x vect_pos.y += vect_dir.y element = target[vect_pos.x][vect_pos.y] list_result.append(element) return list_result # --------------测试代码----------------- list01 = [ [\"00\", \"01\", \"02\", \"03\"], [\"10\", \"11\", \"12\", \"13\"], [\"20\", \"21\", \"22\", \"23\"], ] # 在二维列表中，获取13位置，向左，3个元素 re = DoubleListHelper.get_elements(list01, Vector2(1, 3), Vector2.left(), 3) for item in re: print(item) # 在二维列表中，获取22位置，向上，2个元素 re = DoubleListHelper.get_elements(list01, Vector2(2, 2), Vector2.up(), 2) for item in re: print(item) # 在二维列表中，获取03位置，向下，2个元素 re = DoubleListHelper.get_elements(list01, Vector2(0, 3), Vector2.down(), 2) for item in re: print(item) 我们把以上的代码分成一个逻辑处理模块(DoubleListHelper.py)，一个调用入口(main.py) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-31 21:31:20 "},"chapter10/package_01.html":{"url":"chapter10/package_01.html","title":"定义及作用","keywords":"","body":"模块定义及作用 1.定义 将模块以文件夹的形式进行分组管理。 2.作用 让一些相关的模块组织在一起，使逻辑结构更加清晰。 3.相关概念 \"\"\" 模块相关概念 \"\"\" # from module01 import * # # fun01() # # 1. 隐藏成员，不能通过from 模块 import × 形式导入 # _fun02() # from module01 import _fun02 # # # 隐藏成员，可以通过其他形式调用 # _fun02() # 2. 通过__all__指定可导出成员 from module01 import * MyClass.fun03() _fun02() # 3.可以通过该属性，查看文档注释 print(__doc__) # 4.返回当前模块的绝对路径（从系统根目录开始计算的） print(__file__) # 5. # 现象： # 主模块叫做：__main__ # 非主模块叫做：真名 print(__name__) # 作用1： 不是主模块不执行。(测试代码) # 作用2： 只有是主模块才执行。(主模块代码) # 使用： if __name__ == \"__main__\": pass Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:20:04 "},"chapter12/package_02.html":{"url":"chapter12/package_02.html","title":"导入","keywords":"","body":"包的导入 import 包名 [as 包别名] 需要设置__all__ import 包名.模块名 [as 模块新名] import 包名.子包名.模块名 [as 模块新名] from 包名 import 模块名 [as 模块新名] from 包名.子包名 import 模块名 [as 模块新名] from 包名.子包名.模块名 import 成员名 [as 属性新名] 导入包内的所有子包和模块 from 包名 import * from 包名.模块名 import * 可以通过from 包.模块 import 方法/变量(前提是方法和变量没有在类中) 注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。 import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。 反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。 [节选自菜鸟教程] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 14:40:20 "},"chapter12/package_03.html":{"url":"chapter12/package_03.html","title":"搜索顺序","keywords":"","body":"搜索顺序 sys.path 提供的路径 Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。 这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。 搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码： >>> import sys >>> sys.path ['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages'] >>> sys.path 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。 因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。 了解了搜索路径的概念，就需要自己尝试在Linux系统下不使用PyCharm 软件来尝试运行一次.py文件。 而在日常开发中，由于我们使用了强大的编辑器,才不需要关心sys.path的路径问题，但是如果需要你自己把项目部署在服务器上呢？ 实际容错解决方案参考： [注意]：从哪开始执行，谁就是主模块，主模块所在的那个包称为根目录，此时的根目录是否和项目的根模块是一致的。如果不是一致的，此时如果不在pycharm运行此目录，则会发生导包失败，将项目根目录导入的path中，导包才会成功。那么如何才能导包呢？ 如图所示： 如图导出的是，在一main模块为主模块的时候，程序的搜索路径。 那么怎样才算是导包成功呢？ 当导入的路径（如：import xxxx 或from 包.模块）中的引入模块的地址与该程序下的搜索地址（sys.path）能够顺利找到这个模块的时候，才能导入成功。 pycharm有一个mark功能（下文所示），这个功能能把几个包设置成一个项目，程序能够自动将所有的搜索路径添加进去，但是如果不用pycharm运行，此时，在common中任何一个模块中导入main模块，都不会导包成功，因为搜索路径中没有包含需要的路径（及C:\\Users\\julun\\PycharmProjects\\untitled6\\my_project） 举个例子： （这个图是没有mark的，此时搜索地址中，没有myproject的路径（及C:\\Users\\julun\\PycharmProjects\\untitled6\\my_project）），所以导入main1模块失败，因为搜索地址+“mian1”没办法找到main1, （这个图是mark以后的，此时的搜索地址里面有my_project的路径，能够通过搜索路径+“main1”找到main1模块，所以能够导入成功。）my_project搜索地址如下： 拓展 ----> 用于协助上面文字的理解 mark Directory as 是将包里的文件设置成一个项目，这样该项目里面的模块就可以随意调用。 如果不是用pycharm运行程序，可以这样手动添加路径。 sys.path()返回一个搜索路径的列表。所以可以用append来进行添加。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 15:17:45 "},"chapter12/package_04.html":{"url":"chapter12/package_04.html","title":"init文件","keywords":"","body":"init.py 文件 是包内必须存在的文件 会在包加载时被自动调用 __all__ 记录from 包 import * 语句需要导入的模块 案例： my_ project / main.py common/ __init__.py double_list_helper.py list_helper.py skill_system/ __init__.py skill_deployer.py skill_manager.py 练习: 1.在main.py中调用skill_deployer.py。 2.在skill_deployer.py中调用skill_manager.py。 3.在skill_manager.py中调用double_list_helper.py。 4.在list_helper.py中调用main.py。 要求：在所有的调用过程中，要包含函数、类、实例方法、静态方法。 # 定义：当前模块哪些成员可以被 from 模块 import * 导入 __all__ = [\"fun01\",\"MyClass\",\"_fun02\"] print(\"模块1\") def fun01(): print(\"模块1的fun01\") # 只是在模块内部使用的成员，可以以单下划线开头. # 只限于 from 模块 import * 有效 def _fun02(): print(\"模块1的fun02\") class MyClass: @staticmethod def fun03(): print(\"MyClass -- fun03\") print(__name__) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:36:09 "},"chapter11/":{"url":"chapter11/","title":"异常处理 Error","keywords":"","body":"Chapter02 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-30 21:50:18 "},"chapter11/error_01.html":{"url":"chapter11/error_01.html","title":"异常","keywords":"","body":"异常 1.定义：运行时检测到的错误。 2.现象：当异常发生时，程序不会再向下执行，而转到函数的调用语句。 3.常见异常类型： 异常 说明 场景 NameError 名称异常 变量未定义 TypeError 类型异常 不同类型数据进行运算 IndexError 索引异常 超出索引范围 AttributeError 属性异常 对象没有对应名称的属性 KeyError 键异常 没有对应名称的键 NotImplementedError 未实现异常 尚未实现的方法 Exception 异常基类(父类、超类) 　 下面是一些在编写代码时候发生的错误类型，仅供大家参考 类型错误提示： TypeError: 'Student' object is not callable 类型错误:“Student”对象不可调用 TypeError: __str__ returned non-string (type tuple) 类型错误：str返回非字符串（类型元组） TypeError: 'mappingproxy' object is not callable 类型错误:“映射代理”对象不可调用 TypeError: 'dict' object is not callable 类型错误:“dict”对象不可调用 TypeError: 'float' object is not callable TypeError: unsupported operand type(s) for +: 'NoneType' and 'NoneType' 类型错误：不支持+的操作数类型：“NoneType”和“NoneType” 属性错误提示： AttributeError: 'Student' object has no attribute '__age' 属性错误：“Student”对象没有属性“age” AttributeError: can't set attribute 属性错误:无法设置属性 AttributeError: 'NoneType' object has no attribute 'next' AttributeError: module 'socket' has no attribute 'AF_INET' 相信大家都曾遇到过的哈 ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。 连接拒绝错误 OSError: [Errno 48] Address already in use BrokenPipeError: [Errno 32] Broken pipe Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 15:45:04 "},"chapter12/error_02.html":{"url":"chapter12/error_02.html","title":"处理","keywords":"","body":"异常处理 1.语法： try: 可能触发异常的语句 except 错误类型1 [as 变量1]： 处理语句1 except 错误类型2 [as 变量2]： 处理语句2 except Exception [as 变量3]： 不是以上错误类型的处理语句 else: 未发生异常的语句 finally: 无论是否发生异常的语句 2.作用：将程序由异常状态转为正常流程。 3.说明： as 子句是用于绑定错误对象的变量，可以省略； except子句可以有一个或多个，用来捕获某种类型的错误； else子句最多只能有一个； finally子句最多只能有一个，如果没有except子句，必须存在； 如果异常没有被捕获到，会向上层(调用处)继续传递，直到程序终止运行。 异常及处理 ---> 理解 通常程序在自上而下执行的时候，如果发生异常，程序就不会再向下执行，而是转到函数的调用，将问题报出来。 如下图所示：程序会从报错的地方层层返回到调用者，首先div_apple()报错，是main()内部调用他，错误返回到main()，后面又有程序调用main(),最后再将错误返回到最终调用者。 可是在实际开发项目的时候，我们是希望能够将异常处理掉，从而使程序能够继续运行下去，而不是让他停止运行，所以这个时候，异常处理就要用到了。 如下图所示 （一般不能处理的错误，但是一定要执行的代码放到finally中执行） 这样的话，如果程序异常的话，不会再向上面返回调用者，而是继续按照程序要求执行相应的代码，因为程序不再因为异常而阻断，而是继续执行下去，所有程序后续代码(红色标出部分)不会受程序异常影响而继续运行。 如图： 练习题： \"\"\" 定义函数：在控制台中获取成绩的函数， 要求：如果异常，继续获取成绩，直到得到正确的成绩为止，成绩还必须在0-100之间 \"\"\" def get_score(): \"\"\" 获取学生成绩 :return: \"\"\" while True: try: score = int(input(\"请输入成绩：\")) except Exception: continue if 0 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 15:27:56 "},"chapter12/raise.html":{"url":"chapter12/raise.html","title":"raise 语句","keywords":"","body":"raise 语句 作用： 抛出一个错误，让程序进入异常状态。 目的： 在程序调用层数较深时，向主调函数传递错误信息要层层return 比较麻烦，所以人为抛出异常，可以直接传递错误信息。。 前面已经提到，如果程序异常，系统会从报错的位置一步步的返回调用者那里，如果系统调用很深，就要返回好多步，为了能够让异常直接返回到调用者，这个时候可以使用raise语句，用于人为抛出一些异常。 演示代码： def age(self, value): \"\"\" 拦截判断用户传入的数据是否合法 :param value: 年龄 有范围显示 \"\"\" if value = 32: raise ValueError(\"年龄有误\") else: self.__age = value Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 15:29:37 "},"chapter12/error_03.html":{"url":"chapter12/error_03.html","title":"自定义异常","keywords":"","body":"自定义异常 1.定义： class 类名Error(Exception): def __init__(self,参数): super().__init__(参数) self.数据 = 参数 2.调用： try: …. raise 自定义异常类名(参数) …. except 定义异常类 as 变量名: 变量名.数据 3.作用：封装错误信息 在实际项目中，有的时候可能需要自己创建相关的错误，这个时候可以创建相关错误类。 比如说像联通，每一个类有对象的编号，这些都可以自己设定。 4.用户自定义异常类演示代码： 你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承. 例如: # 自定义异常类1 class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) # ------------------------------------------- try: raise MyError(2 * 2) except MyError as e: print('My exception occurred, value:', e.value) raise MyError('oops!') 执行结果： My exception occurred, value: 4 Traceback (most recent call last): File \"\", line 14, in raise MyError('oops!') __main__.MyError: 'oops!' \"\"\" 自定义异常类2 \"\"\" class AgeError(Exception): \"\"\" 年龄错误 \"\"\" def __init__(self,message,age_value,code_line,error_number): super().__init__(\"出错啦啦啦\") self.message = message self.age_value = age_value self.code_line = code_line self.error_number = error_number class Wife: def __init__(self,age): self.age = age @property def age(self): return self.__age @age.setter def age(self,value): if 21 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:25:46 "},"chapter12/":{"url":"chapter12/","title":"迭代","keywords":"","body":"复习 \"\"\" 迭代 可迭代对象 迭代器 生成器 class 可迭代对象: def __iter__(): 创建迭代器对象 class 迭代器: def __next__(): 返回一个元素 如果没有元素,则抛出一个StopIteration异常. for 变量 in 可迭代对象: 变量得到的就是__next__方法返回值 原理: iterator = 可迭代对象.__iter__() while True: try: 变量 = iterator.__next__() exercep: break 启发:调用next执行一次,计算一次,返回一次. 生成器函数: def 函数名(): ... yield 数据 ... # 调用方法不执行 生成器 = 函数名() # for 生成器 才执行函数体 for item in 生成器: ... 优势:延迟/惰性操作 生成器源码 class 生成器: def __iter__(): return self def __next__(): 定义着yield以前的代码 返回yield后面的数据 \"\"\" Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 01:03:02 "},"chapter12/iterable.html":{"url":"chapter12/iterable.html","title":"可迭代对象 iterable","keywords":"","body":"可迭代对象 iterable 1.定义：具有iter函数的对象，可以返回迭代器对象。 2.语法 -- 创建： class 可迭代对象名称: def __iter__(self): return 迭代器 -- 使用： for 变量名 in 可迭代对象: 语句 3.原理： 迭代器 = 可迭代对象.__iter__() while True: try: print(迭代器.__next__()) except StopIteration: break # 可迭代对象 -- 容器/序列 list01 = [43,3,4,5,567] # 迭代过程 for item in list01: print(item) 练习题：不用for语句遍历任何一个容器 \"\"\" 可迭代对象----容器 \"\"\" list_number = [34, 5, 3, 4, 87] # 迭代过程 # for i in list_number: # print(i) # 步骤如下： # 1、获取迭代器 iterator = list_number.__iter__() # 2、循环获取下一个元素 while True: try: item = iterator.__next__() print(item) # 3、遇到异常停止迭代 except StopIteration: break 执行结果： 34 5 3 4 87 涉及到的面试题 迭代原理 1、for循环的原理是什么？ - 获取迭代器 - 循环获取下一个元素 - 遇到异常停止迭代 2、可以被for的条件是什么？ - 能被for的对象必须拥有__iter__方法 - 能被for的对象必须是可迭代对象 因为可迭代对象才会有__iter__这个方法 个人理解（for语句的本质） 其实for语句内部执行的过程就是迭代器对象迭代的过程 Exercise 练习1： # 练习1：使用迭代器原理，遍历元组. # (\"铁扇公主\",\"铁锤公主\",“扳手王子”) tuple01 = (\"铁扇公主\",\"铁锤公主\",\"扳手王子\") # for item in tuple01: # print(item) iterator = tuple01.__iter__() while True: try: item = iterator.__next__() print(item) except StopIteration: break 练习2： # 练习2:不使用for，获取字典所有数据。 # {\"铁扇公主\":101,\"铁锤公主\":102,“扳手王子”:103} dict01 = {\"铁扇公主\": 101, \"铁锤公主\": 102, \"扳手王子\": 103} iterator = dict01.__iter__() while True: try: key = iterator.__next__() print(key, dict01[key]) except StopIteration: break Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 16:12:44 "},"chapter12/iterator.html":{"url":"chapter12/iterator.html","title":"迭代器对象 iterator","keywords":"","body":"迭代器对象 iterator 1.定义：可以被next()函数调用并返回下一个值的对象。 2.语法 class 迭代器类名: def __init__(self, 聚合对象): self.聚合对象= 聚合对象 def __next__(self): if 没有元素: raise StopIteration return 聚合对象元素 3.说明： -- 聚合对象通常是容器对象。 4.作用：使用者只需通过一种方式，便可简洁明了的获取聚合对象中各个元素，而又无需了解其内部结构。 原理图： 相关演示代码： \"\"\" 迭代器 --> yield \"\"\" class MyRange: def __init__(self, stop_value): self.stop_value = stop_value def __iter__(self): # return MyRangeIterator(self.stop_value) # 0 --> self.stop_value # yield 作用: 将下列代码改为迭代器模式的代码. # 生成迭代器代码的大致规则: # 1. 将yield以前的语句定义在next方法中 # 2. 将yield后面的数据作为next方法返回值 number = 0 while number yield --> 生成器 \"\"\" yield --> 生成器 \"\"\" \"\"\" class MyRange: def __init__(self, stop_value): self.stop_value = stop_value def __iter__(self): number = 0 while number = self.stop_value: raise StopIteration temp = self.begin self.begin+=1 return temp \"\"\" def my_range(stop_value): number = 0 while number Exercise 练习：图形管理器记录多个图形 # 练习：图形管理器记录多个图形 # 迭代图形管理器对象 class Graphic: pass class GraphicManager: \"\"\" 图形管理器，可迭代对象(参与for) \"\"\" def __init__(self): self.__graphics = [] def add_graphic(self, graphic): self.__graphics.append(graphic) def __iter__(self): return GraphicIterator(self.__graphics) class GraphicIterator: \"\"\" 图形迭代器（获取下一个数据） \"\"\" def __init__(self, target): self.__target = target self.__index = 0 def __next__(self): if self.__index > len(self.__target) - 1: raise StopIteration temp = self.__target[self.__index] self.__index += 1 return temp manager = GraphicManager() manager.add_graphic(Graphic()) manager.add_graphic(Graphic()) manager.add_graphic(Graphic()) # for item in manager: # print(item) iterator = manager.__iter__() while True: try: item = iterator.__next__() print(item) except StopIteration: break 练习：员工管理器记录多个员工 # 练习：员工管理器记录多个员工 # 迭代员工管理器对象 class Employee: pass class EmployeeManager: def __init__(self): self.__employees = [] def add_employee(self, emp): self.__employees.append(emp) def __iter__(self): return EmployeeIterator(self.__employees) class EmployeeIterator: \"\"\" 员工迭代器（获取下一个数据） \"\"\" def __init__(self, target): self.__target = target self.__index = 0 def __next__(self): if self.__index > len(self.__target) - 1: raise StopIteration temp = self.__target[self.__index] self.__index += 1 return temp manager = EmployeeManager() manager.add_employee(Employee()) manager.add_employee(Employee()) manager.add_employee(Employee()) for item in manager: print(item) # 多态 iterator = manager.__iter__() while True: try: item = iterator.__next__() print(item) except StopIteration: break 练习：定义MyRange类，实现for功能 \"\"\" 练习：定义MyRange类，实现下列功能 for item in range(10): print(item) \"\"\" class MyRange: def __init__(self, stop_value): self.stop_value = stop_value def __iter__(self): return MyRangeIterator(self.stop_value) class MyRangeIterator: def __init__(self, end_value): self.__end_value = end_value self.__number = 0 def __next__(self): if self.__number == self.__end_value: raise StopIteration temp = self.__number self.__number += 1 return temp # next一次，计算一次，返回一次。 for item in MyRange(99999999999999): print(item) 练习: 将迭代器版本的图形管理器改为yield实现. class Graphic: pass class GraphicManager: \"\"\" 图形管理器，可迭代对象(参与for) \"\"\" def __init__(self): self.__graphics = [] def add_graphic(self, graphic): self.__graphics.append(graphic) def __iter__(self): # 执行过程: # 1. 调用当前方法,不执行.(内部创建迭代器对象) # 2. 调用__next__方法,才执行. # 3. 执行到yield语句,暂时离开. # 4. 再次调用__next__方法,继续执行. # 5. 重复第3/4步骤.直至最后. for item in self.__graphics: yield item manager = GraphicManager() manager.add_graphic(Graphic()) manager.add_graphic(Graphic()) manager.add_graphic(Graphic()) # for item in manager: # print(item) iterator = manager.__iter__() while True: try: item = iterator.__next__() print(item) except StopIteration: break 练习:从列表[4,5,566,7,8,10]中选出所有偶数 # 练习:从列表[4,5,566,7,8,10]中选出所有偶数 # -- 结果存入另外一个列表中 # -- 使用生成器实现 list01 = [4,5,566,7,8,10] def get_even01(): result = [] for item in list01: if item % 2 == 0: result.append(item) return result re = get_even01() for item in re: print(item) def get_even02(): for item in list01: if item % 2 == 0: yield item g01 = get_even02() for item in g01: print(item) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 16:26:27 "},"chapter13/":{"url":"chapter13/","title":"生成器 generator","keywords":"","body":"生成器 1.定义：能够动态(循环一次计算一次返回一次)提供数据的可迭代对象。 2.作用：在循环过程中，按照某种算法推算数据，不必创建容器存储完整的结果，从而节省内存空间。数据量越大，优势越明显。 3.以上作用也称之为延迟操作或惰性操作，通俗的讲就是在需要的时候才计算结果，而不是一次构建出所有结果。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 01:03:20 "},"chapter13/generator_01.html":{"url":"chapter13/generator_01.html","title":"生成器函数","keywords":"","body":"生成器函数 1.定义： 含有yield语句的函数，返回值为生成器对象。 2.语法 -- 创建： def 函数名(): … yield 数据 … -- 调用： for 变量名 in 函数名(): 语句 3.说明： -- 调用生成器函数将返回一个生成器对象，不执行函数体。 -- yield 翻译为 ”产生” 或 ”生成”。 4.执行过程： (1)调用生成器函数会自动创建迭代器对象。 (2)调用迭代器对象的next()方法时才执行生成器函数。 (3)每次执行到yield语句时返回数据，暂时离开。 (4)待下次调用next()方法时继续从离开处继续执行。 5.原理： 生成迭代器对象的大致规则如下 -- 将yield关键字以前的代码放在next方法中。 -- 将yield关键字后面的数据作为next方法的返回值。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:38:46 "},"chapter13/generator_02.html":{"url":"chapter13/generator_02.html","title":"内置生成器","keywords":"","body":"内置生成器 枚举函数 enumerate 1.语法： for 变量 in enumerate(可迭代对象): 语句 for 索引, 元素in enumerate(可迭代对象): 语句 2.作用：遍历可迭代对象时，可以将索引与元素组合为一个元组。 zip 1.语法： for item in zip(可迭代对象1, 可迭代对象2….): 语句 2.作用： 将多个可迭代对象中对应的元素组合成一个个元组，生成的元组个数由最小的可迭代对象决定。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 01:03:49 "},"chapter13/generator_03.html":{"url":"chapter13/generator_03.html","title":"生成器表达式","keywords":"","body":"生成器表达式 1.定义： 用推导式形式创建生成器对象。 2.语法： 变量 = ( 表达式 for 变量 in 可迭代对象 [if 真值表达式] ) 3.相关演示代码 \"\"\" 生成器表达式 \"\"\" list01 = [3, \"54\", True, 6, \"76\", 1.6, False, 3.5] # 生成器函数 def find01(): for item in list01: if type(item) == int: yield item + 1 re = find01() for item in re: print(item) # 生成器表达式 # 此时没有计算,更没有结果 re = (item + 1 for item in list01 if type(item) == int) # 一次循环,一次计算,一个结果 for item in re: print(item) # 列表推导式 # 此时已经完成所有计算,得到所有结果 re = [item + 1 for item in list01 if type(item) == int] # 只是获取所有结果 for item in re: print(item) # 变量 = [itme for item in 可迭代对象 if 条件] 列表推导 # 变量 = {k,v for k,v in 可迭代对象 if 条件} 字典推导 # 变量 = {item for item in 可迭代对象 if条件} 集合推导 # 变量 = (item for item in 可迭代对象 if条件) 生成器表达式 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:55:22 "},"chapter13/generator_04.html":{"url":"chapter13/generator_04.html","title":"阐述迭代器和生成器","keywords":"","body":"面试题： 请简单阐述一下迭代器和生成器之间的关系？ 生成器本质：迭代器 + 可迭代对象； 生成器最重要的特点：调用一次next，计算一次结果，返回一个结果； 而这个过程称之为：惰性操作/延迟操作； 生成器优点：在海里数据下，可以大量节省内存； 生成器缺点：惰性操作/延迟操作 如果将惰性操作改为立即操作呢？ list(生成器) -----> 可以灵活的获取结果（相对也就失去了生成器的优势。） 可迭代对象：就是为了可以迭代（for）； 迭代的本质：不断调用__next__方法； Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:56:04 "},"chapter14/":{"url":"chapter14/","title":"函数式编程","keywords":"","body":"函数式编程 1.定义： -- 用一系列函数解决问题。 -- 函数可以赋值给变量，赋值后变量绑定函数。 -- 允许将函数作为参数传入另一个函数。 -- 允许函数返回一个函数。 2.高阶函数： 将函数作为参数或返回值的函数。 3.函数作为参数 将核心逻辑传入方法体，使该方法的适用性更广，体现了面向对象的开闭原则。 4.函数作为返回值 逻辑连续，当内部函数被调用时，不脱离当前的逻辑。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:57:10 "},"chapter14/func_01.html":{"url":"chapter14/func_01.html","title":"函数作为参数","keywords":"","body":"将核心逻辑传入方法体，使该方法的适用性更广，体现了面向对象的开闭原则。 函数作为参数 函数作为返回值 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-29 15:36:17 "},"chapter14/lambda.html":{"url":"chapter14/lambda.html","title":"lambda 表达式","keywords":"","body":"lambda 表达式 1.定义： 是一种匿名方法。 2.作用： 作为参数传递时语法简洁，优雅，代码可读性强。 随时创建和销毁，减少程序耦合度。 3.语法 定义： 变量 = lambda 形参: 方法体 语法:lambda 参数列表:函数体 注意:函数体自带return 调用： 变量(实参) 4.说明： 形参没有可以不填 方法体只能有一条语句，且不支持赋值语句。 使用lambda公式 x = lambda a, b, c : a + b + c print(x(5, 10, 20)) # 35 # 或者也可以这样 def x(a, b, c): return a + b + c print(x(5, 10, 30)) # 35 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 01:01:02 "},"chapter14/func_02.html":{"url":"chapter14/func_02.html","title":"内置高阶函数","keywords":"","body":"内置高阶函数 函数 解释 map（函数，可迭代对象） 使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。 filter(函数，可迭代对象) 根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。 sorted(可迭代对象，key = 函数,reverse = bool值) 排序，返回值为排序结果。 max(可迭代对象，key = 函数) 根据函数获取可迭代对象的最大值。 min(可迭代对象，key = 函数) 根据函数获取可迭代对象的最小值。 1.map函数 map函数：map函数是相当于通过一个函数将输入变量一一映射（通过某类函数）进行输出。 map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回 def fuc(x): return x*x r = map(fuc,[1,2,3]) print(list(r)) # 交互模式下 >>> map(str,[1,2,3,4,5]) >>> list(map(str,[1,2,3,4,5])) ['1', '2', '3', '4', '5'] 为什么需要map这样的函数了？ 因为map函数第一个参数是作用的函数，我们可以通过这个函数清楚的知道这个函数具体的作用是什么，起到了见名知意的作用。 使用map函数 对一个列表每一个元素都进行操作的话,可以用map函数,下边是个小案例 def multiply(n): return n*n list1 =[1, 2, 3] result = list(map(multiply, list1)) print(result) # [1, 4, 9] 2.filter()函数 filter函数也是接收一个函数和一个序列的高阶函数，其主要功能是过滤。其返回值也是迭代器对象 Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。 和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。所以filter和map区别一点就是filter就像滤波器一样会保留或者丢掉一些元素，但是map是不会丢弃元素的，只是会作用在一些元素上面的。 def is_odd(num): # if(num%2==1): # return num return num % 2 == 1 # 这句话的含义就是先进行判断然后进行合适数字的输出 print(list(filter(is_odd, [1, 2, 3, 4, 5, 6]))) # filter和map类似的，输出的也是一个惰性序列，需要通过List强制进行转换 # 运行结果：[1, 3, 5] 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 使用过滤函数-filter arr = [1, 2, 3, 4, 5] def Even(x): return list(filter(lambda x: x % 2 == 0, arr)) Even(arr) # [2, 4] 3.sorted()排序函数 sort函数直接可以作用于list中，表示对其进行排序， sorted函数也是一个高阶函数，里面也是可以传入其他的参数 # 默认是从小到大进行排序 print(sorted([1, 2, 49, -11])) # [-11, 1, 2, 49] # 通过reverse属性，表示我们使用反向排序，也就是从大到小进行排序 print(sorted([1, 2, 49, -11], reverse=True)) # [49, 2, 1, -11] # 按照绝对值从小到大进行排序 print(sorted([1, 2, 49, -11], key=abs)) # [1, 2, -11, 49] # 这个sorted对字符串进行排序的时候是根据首字符的ASCII进行排序的 print(sorted(['abs', 'Ab', 'ZO'])) # ['Ab', 'ZO', 'abs'] # 这个表示按照字符串首字母进行排序 print(sorted(['abs', 'Ab', 'ZO'], key=str.lower)) # ['Ab', 'abs', 'ZO'] Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-03 18:36:38 "},"chapter14/func_03.html":{"url":"chapter14/func_03.html","title":"自定义高阶函数","keywords":"","body":"函数作为参数 自定义高阶函数　list_helper.py github地址：https://github.com/ssk1987/Helper-Classes 对比Python的内置高阶函数 函数 解释 map（函数，可迭代对象） ListHelper.select(可迭代对象,函数)。 filter(函数，可迭代对象) ListHelper.find_all(可迭代对象,函数)。 max(可迭代对象，key = 函数) ListHelper.get_max(可迭代对象,函数)。 min(可迭代对象，key = 函数) sorted(可迭代对象，key = 函数,reverse = bool值) ListHelper.order_by(可迭代对象,函数)。 sorted(可迭代对象，key = 函数,reverse = True) 降序。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-29 21:08:05 "},"chapter14/func_04.html":{"url":"chapter14/func_04.html","title":"函数作为返回值","keywords":"","body":"逻辑连续，当内部函数被调用时，不脱离当前的逻辑。 闭包 函数装饰器 decorators Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2019-12-29 15:33:15 "},"chapter14/func_05.html":{"url":"chapter14/func_05.html","title":"闭包","keywords":"","body":"闭包 重点：掌握闭包 1.概念： 闭包并不只是一个python中的概念，在函数式编程语言中应用较为广泛。 理解python中的闭包一方面是能够正确的使用闭包，另一方面可以好好体会和思考闭包的设计思想。 2.三要素 必须有一个内嵌函数。 内嵌函数必须引用外部函数中变量。 外部函数返回值必须是内嵌函数。 3.语法 定义： def 外部函数名(参数): 外部变量 def 内部函数名(参数): 使用外部变量 return 内部函数名 调用： 变量 = 外部函数名(参数) 变量(参数) 4.定义： 在一个函数内部的函数,同时内部函数又引用了外部函数的变量。 5.本质： 闭包是将内部函数和外部函数的执行环境绑定在一起的对象。** 6.优点： 内部函数可以使用外部变量。 7.缺点： 外部变量一直存在于内存中，不会在调用结束后释放，占用内存。 8.作用： 实现python装饰器。 9.闭包演示 def fun01(): a = 1 def fun02(): print(a) return fun02 # 调用外部函数，返回值是内嵌函数 result = fun01() # 调用内嵌函数 result() # 可以访问外部变量a # 闭包应用:逻辑连续，当内部函数被调用时，不脱离当前的逻辑 # 压岁钱 def give_gife_money(money): \"\"\" 得到压岁钱 :return: \"\"\" print(\"得到了%d压岁钱\" % money) def child_buy(target, price): \"\"\" 孩子购买商品 :param target: 需要购买的商品 :param price: 商品单价 \"\"\" nonlocal money if money >= price: money -= price print(\"孩子花了%.1f钱，购买了%s\" % (price, target)) else: print(\"钱不够啦\") return child_buy # 下列代码是一个连续的逻辑 action = give_gife_money(10000) action(\"唐僧肉\", 0.5) action(\"小汽车\", 2000) action(\"手机\", 8000) 10.闭包案例 def func(a, b): def line(x): return a * x - b return line line = func(2, 3) print(line(5)) 结果得到 7 在这个案例中，外函数func有接收参数 a=2，b=3，内函数line接收参数x=5，在内函数体中计算了a*x-b 即 2×5-3的值作为返回值，外函数返回内函数的引用，这里的引用指的是内函数line在内存中的起始地址，最终调用内函数line()得到返回值7 11.内函数中修改外函数的值 一般在函数结束时，会释放临时变量，但在闭包中，由于外函数的临时变量在内函数中用到，此时外函数会把临时变量与内函数绑定到一起，这样虽然外函数结束了，但调用内函数时依旧能够使用临时变量，即闭包外层的参数可以在内存中进行保留。 如果想要在内函数中修改外函数的值，需要使用 nonlocal 关键字声明变量。 def func(a, b): def line(x): nonlocal a a = 3 return a * x - b return line line = func(2, 3) print(line(5)) 此时运行结果为：12 参考文献及资料： https://www.cnblogs.com/yssjun/p/9887239.html https://blog.csdn.net/weixin_44141532/article/details/87116038 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:54:07 "},"chapter14/decorators.html":{"url":"chapter14/decorators.html","title":"函数装饰器 decorators","keywords":"","body":"函数装饰器 1.定义： 在不改变原函数的调用以及内部代码情况下，为其添加新功能的函数。 2.语法 def 函数装饰器名称(func): def 内嵌函数(*args, **kwargs): 需要添加的新功能 return func(*args, **kwargs) return wrapper @ 函数装饰器名称 def 原函数名称(参数): 函数体 原函数(参数) 3.本质 使用“@函数装饰器名称”修饰原函数，等同于创建与原函数名称相同的变量，关联内嵌函数；故调用原函数时执行内嵌函数。 原函数名称 = 函数装饰器名称（原函数名称） 4.装饰器链： 一个函数可以被多个装饰器修饰，执行顺序为从近到远。 5.相关演示 \"\"\" 装饰器 \"\"\" # 需求：对以下两个功能增加权限验证. \"\"\" # 需要增加的功能 def verify_permissions(): print(\"权限验证\") # 已有功能 def enter_background(): verify_permissions() print(\"进入后台\") def delete_order(): verify_permissions() print(\"删除订单\") enter_background() delete_order() # 缺点：增加新功能，需要修改已有功能． [违反开闭原则] \"\"\" \"\"\" # 需要增加的功能 def verify_permissions(func): def wrapper(): print(\"权限验证\") func() return wrapper # 已有功能 def enter_background(): print(\"进入后台\") def delete_order(): print(\"删除订单\") # enter_background = 新功能 + 旧功能 enter_background = verify_permissions(enter_background) delete_order = verify_permissions(delete_order) enter_background() delete_order() 缺点：每次拦截对已有功能(enter_background)的调用,不科学. \"\"\" \"\"\" # 需要增加的功能 def verify_permissions(func): def wrapper(): print(\"权限验证\") func() return wrapper # 已有功能 # enter_background = verify_permissions(enter_background) @verify_permissions def enter_background(): print(\"进入后台\") @verify_permissions def delete_order(): print(\"删除订单\") enter_background() delete_order() 缺点：如果已有功能参数不统一，则无法包装. \"\"\" def verify_permissions(func): def wrapper(*args, **kwargs): print(\"权限验证\") func(*args, **kwargs) return wrapper # 已有功能 @verify_permissions def enter_background(login_id, pwd): print(login_id, pwd, \"进入后台\") @verify_permissions def delete_order(id): print(\"删除订单\", id) # enter_background = verify_permissions(enter_background) # delete_order = verify_permissions(delete_order) enter_background(\"abc\", 1234) delete_order(101) Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:42:08 "},"exercise/exercise_items.html":{"url":"exercise/exercise_items.html","title":"练习项目","keywords":"","body":"项目化，实战化 信息管理系统贯穿 Python 核心。 天龙八部技能系统贯穿面向对象。 集成操作框架贯穿 Python 高级。 2048 游戏贯穿第一阶段。 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 10:57:27 "},"exercise/shopping.html":{"url":"exercise/shopping.html","title":"购物车重构","keywords":"","body":"重构购物车 shopping.py 1.重构前代码 shang_pin_info = { 101: {\"name\": \"屠龙刀\", \"price\": 10000}, 102: {\"name\": \"倚天剑\", \"price\": 10000}, 103: {\"name\": \"九阴白骨爪\", \"price\": 8000}, 104: {\"name\": \"九阳神功\", \"price\": 9000}, 105: {\"name\": \"降龙十八掌\", \"price\": 8000}, 106: {\"name\": \"乾坤大挪移\", \"price\": 10000} } ding_dan = [] def gou_wu(): \"\"\" 购物 :return: \"\"\" while True: item = input(\"1键购买，2键结算。\") if item == \"1\": for key, value in shang_pin_info.items(): print(\"编号：%d，名称：%s，单价：%d。\" % (key, value[\"name\"], value[\"price\"])) while True: cid = int(input(\"请输入商品编号：\")) if cid in shang_pin_info: break else: print(\"该商品不存在\") count = int(input(\"请输入购买数量：\")) ding_dan.append({\"cid\": cid, \"count\": count}) print(\"添加到购物车。\") elif item == \"2\": zong_jia = 0 for item in ding_dan: shang_pin = shang_pin_info[item[\"cid\"]] print(\"商品：%s，单价：%d,数量:%d.\" % (shang_pin[\"name\"], shang_pin[\"price\"], item[\"count\"])) zong_jia += shang_pin[\"price\"] * item[\"count\"] while True: qian = float(input(\"总价%d元，请输入金额：\" % zong_jia)) if qian >= zong_jia: print(\"购买成功，找回：%d元。\" % (qian - zong_jia)) ding_dan.clear() break else: print(\"金额不足.\") gou_wu() 2.重构后代码 仅供参考,每人的思路不一样,出来的代码也不一样 dict_commodity_info = { 101: {\"name\": \"屠龙刀\", \"price\": 10000}, 102: {\"name\": \"倚天剑\", \"price\": 10000}, 103: {\"name\": \"九阴白骨爪\", \"price\": 8000}, 104: {\"name\": \"九阳神功\", \"price\": 9000}, 105: {\"name\": \"降龙十八掌\", \"price\": 8000}, 106: {\"name\": \"乾坤大挪移\", \"price\": 10000} } list_order = [] def select_menu(): \"\"\" 选择菜单 \"\"\" while True: item = input(\"1键购买，2键结算。\") if item == \"1\": buying() elif item == \"2\": settlement() def settlement(): \"\"\" 结算 \"\"\" print_orders() total_price = calculate_total_price() paying(total_price) def paying(total_price): \"\"\" 支付过程 :param total_price: 需要支付的价格 \"\"\" while True: money = float(input(\"总价%d元，请输入金额：\" % total_price)) if money >= total_price: print(\"购买成功，找回：%d元。\" % (money - total_price)) list_order.clear() break else: print(\"金额不足.\") def calculate_total_price(): \"\"\" 计算总价格 \"\"\" total_price = 0 for order in list_order: commodity = dict_commodity_info[order[\"cid\"]] total_price += commodity[\"price\"] * order[\"count\"] return total_price def print_orders(): \"\"\" 打印订单 \"\"\" for order in list_order: commodity = dict_commodity_info[order[\"cid\"]] print(\"商品：%s，单价：%d,数量:%d.\" % (commodity[\"name\"], commodity[\"price\"], order[\"count\"])) def buying(): \"\"\" 购买 \"\"\" print_commodity_info() create_order() print(\"添加到购物车。\") def create_order(): \"\"\" 创建订单 \"\"\" cid = input_commodity_id() count = int(input(\"请输入购买数量：\")) order = {\"cid\": cid, \"count\": count} list_order.append(order) def input_commodity_id(): \"\"\" 获取商品订单 \"\"\" while True: cid = int(input(\"请输入商品编号：\")) if cid in dict_commodity_info: break else: print(\"该商品不存在\") return cid def print_commodity_info(): \"\"\" 打印商品信息 \"\"\" for key, value in dict_commodity_info.items(): print(\"编号：%d，名称：%s，单价：%d。\" % (key, value[\"name\"], value[\"price\"])) select_menu() 3.面向对象购物车 class CommodityModel: \"\"\" 商品模型 \"\"\" def __init__(self, id=0, name=\"\", price=0): self.id = id self.name = name self.price = price class OrderModel: \"\"\" 订单模型 \"\"\" def __init__(self, commodity=None, count=0, id=0): self.id = id self.commodity = commodity self.count = count class ShoppingCartController: \"\"\" 购物车逻辑控制器 \"\"\" init_order_id = 0 def __init__(self): self.__list_order = [] self.__list_commodity_info = self.__load_commodity() @property def list_order(self): return self.__list_order @property def list_commodity_info(self): return self.__list_commodity_info def __load_commodity(self): \"\"\" 加载商品信息 :return: 商品列表 \"\"\" return [ CommodityModel(101, \"屠龙刀\", 10000), CommodityModel(102, \"倚天剑\", 10000), CommodityModel(103, \"九阴白骨爪\", 8000), CommodityModel(104, \"九阳神功\", 9000), CommodityModel(105, \"降龙十八掌\", 8000), ] def add_order(self, order_base_info): \"\"\" 添加订单 :param order:订单基础信息 \"\"\" order_base_info.id = self.__generate_order_id() self.__list_order.append(order_base_info) def __generate_order_id(self): \"\"\" 生成订单编号 :return: 订单编号 \"\"\" ShoppingCartController.init_order_id += 1 return ShoppingCartController.init_order_id def get_total_price(self): \"\"\" 根据订单计算总价格 :return:总价格 \"\"\" total_price = 0 for item in self.__list_order: total_price += item.commodity.price * item.count return total_price def get_commodity_by_id(self, id): \"\"\" 获取指定的商品 :param id: 商品编号 :return: 商品对象 \"\"\" for item in self.__list_commodity_info: if item.id == id: return item class ShoppingConsoleView: \"\"\" 购物车控制台界面视图 \"\"\" def __init__(self): self.__controller = ShoppingCartController() def __select_menu(self): \"\"\" 菜单选择 \"\"\" while True: item = input(\"1键购买，2键结算。\") if item == \"1\": self.__buying() elif item == \"2\": self.__settlement() def __buying(self): \"\"\" 购买 \"\"\" self.__print_commodity() self.__create_order() print(\"添加到购物车。\") def __print_commodity(self): \"\"\" 打印商品信息 \"\"\" for commodity in self.__controller.list_commodity_info: print(\"编号：%d，名称：%s，单价：%d。\" % (commodity.id, commodity.name, commodity.price)) def __create_order(self): \"\"\" 创建订单 \"\"\" while True: cid = int(input(\"请输入商品编号：\")) # 如果该商品存在，则退出循环，否则重新输入。 commodity = self.__controller.get_commodity_by_id(cid) if commodity: break else: print(\"该商品不存在\") count = int(input(\"请输入购买数量：\")) order = OrderModel(commodity, count) self.__controller.add_order(order) def __settlement(self): \"\"\" 结算 \"\"\" self.__print_order() total_price = self.__controller.get_total_price() self.__pay(total_price) def __print_order(self): \"\"\" 打印订单 \"\"\" for order in self.__controller.list_order: commodity = order.commodity print(\"商品：%s，单价：%d,数量:%d.\" % (commodity.name, commodity.price, order.count)) def __pay(self, total_price): \"\"\" 支付 :param total_price: 需要支付的价格 :return: \"\"\" while True: money = float(input(\"总价%d元，请输入金额：\" % total_price)) if money >= total_price: print(\"购买成功，找回：%d元。\" % (money - total_price)) self.__controller.list_order.clear() break else: print(\"金额不足.\") def main(self): \"\"\" 界面入口 \"\"\" while True: self.__select_menu() view = ShoppingConsoleView() view.main() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:03:09 "},"exercise/2048.html":{"url":"exercise/2048.html","title":"2048游戏","keywords":"","body":"2048游戏 在学习2048游戏之前我们需要先了解一下，矩阵转置的方法 矩阵转置/方阵转置 矩阵解释：在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合. 方阵解释：方阵是古代军队作战时采用的一种队形，是把军队在野外开阔地上排列成方形阵式。远古方阵由前军、中军和后军相互嵌套排列而成，方阵平面呈现“回”字形状，反映出远古观念中的一种政治地理结构，来源于“天圆地方”的宇宙观。 # 练习：定义方阵转置函数 # list01 = [ # [1, 2, 3, 4], # [5, 6, 7, 8], # [9, 10, 11, 12], # [13, 14, 15, 16], # ] # for c in range(1, len(list01)): # 1 2 3 # for r in range(c, len(list01)): # list01[r][c - 1], list01[c - 1][r] = list01[c - 1][r], list01[r][c - 1] # print(list01) def square_matrix_transpose(sqr_matrix): \"\"\" 方阵转置 :param sqr_matrix: 二维列表类型的方阵 \"\"\" for c in range(1, len(sqr_matrix)): for r in range(c, len(sqr_matrix)): sqr_matrix[r][c - 1], sqr_matrix[c - 1][r] = sqr_matrix[c - 1][r], sqr_matrix[r][c - 1] list01 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16], ] # 矩阵转置的转置等于原矩阵 square_matrix_transpose(list01) print(list01) square_matrix_transpose(list01) print(list01) 2048 游戏核心算法 核心代码参考： list_merge = None # 练习１：零元素移至末尾 # 　　[2,0,2,0] --> [2,2,0,0] # [2,0,0,2] --> [2,2,0,0] # [2,4,0,2] --> [2,4,2,0] def zero_to_end(): \"\"\" 零元素移动到末尾. \"\"\" # 思想：从后向前，如果发现零元素，删除并追加. for i in range(-1, -len(list_merge) - 1, -1): if list_merge[i] == 0: del list_merge[i] list_merge.append(0) # 测试．．． # zero_to_end() # print(list_merge) # 练习2：将相同数字合并 14:38 # 　　[2,2,0,0] --> [4,0,0,0] # [2,0,0,2] --> [4,0,0,0] # [2,0,4,0] --> [2,4,0,0] # [2,2,2,2] --> [4,4,0,0] # [2,2,2,0] --> [4,2,0,0] def merge(): \"\"\" 合并 \"\"\" # 先将中间的零元素移到末尾 # 再合并相邻相同元素 zero_to_end() for i in range(len(list_merge) - 1): if list_merge[i] == list_merge[i + 1]: # 将后一个累加前一个之上 list_merge[i] += list_merge[i + 1] del list_merge[i + 1] list_merge.append(0) # 测试... # merge() # print(list_merge) # 练习3:地图向左移动 map = [ [2, 0, 0, 2], [4, 4, 2, 2], [2, 4, 0, 4], [0, 0, 2, 2], ] def move_left(): \"\"\" 向左移动 \"\"\" # 思想:将二维列表中每行交给merge函数进行操作 for line in map: global list_merge list_merge = line merge() # move_left() # print(map) def move_right(): \"\"\" 向右移动 \"\"\" # 思想:将二维列表中每行(从右向左)交给merge函数进行操作 for line in map: global list_merge # 从右向左取出数据　形成　新列表 list_merge = line[::-1] merge() # 从右向左接受　合并后的数据 line[::-1] = list_merge # move_right() # print(map) # 练习4:向上移动　　向下移动 def move_up(): square_matrix_transpose(map) move_left() square_matrix_transpose(map) def move_down(): square_matrix_transpose(map) move_right() square_matrix_transpose(map) # 提示:利用方阵转置函数 def square_matrix_transpose(sqr_matrix): \"\"\" 方阵转置 :param sqr_matrix: 二维列表类型的方阵 \"\"\" for c in range(1, len(sqr_matrix)): for r in range(c, len(sqr_matrix)): sqr_matrix[r][c - 1], sqr_matrix[c - 1][r] = sqr_matrix[c - 1][r], sqr_matrix[r][c - 1] move_down() print(map) 步骤 步骤： 1. 将之前完成的2048算法移动到 　　bll.py-->　GameCoreController　类中． 变量： 合并时使用的一维列表 移动时使用的二维列表 方法： 零元素移至末尾() 合并() 上移动() 下移动() ..... 温馨提示：注意命名(私有化) 2. 在GameCoreController类中，定义产生随机数功能. 需求:在空白的位置上 可能是2(90%),也可能是4(10%). 1 - 10 --> 随机数 是1的概率是10% 1 --100 --> 1 面向对象相关代码 游戏入口 main.py \"\"\" 游戏入口 \"\"\" from ui import GameConsoleView if __name__ ==\"__main__\": view = GameConsoleView() view.main() 数据模型 model.py \"\"\" 数据模型 \"\"\" class DirectionModel: \"\"\" 方向数据模型 枚举 常量(命名全部大写) \"\"\" # 在整数基础上，添加一个人容易识别的\"标签\" UP = 0 DOWN = 1 LEFT = 2 RIGHT = 3 class Location: \"\"\" 位置 \"\"\" def __init__(self,r,c): self.r_index = r self.c_index = c 游戏逻辑控制器，负责处理游戏核心算法． bll.py \"\"\" 游戏逻辑控制器，负责处理游戏核心算法． \"\"\" from model import DirectionModel from model import Location import random class GameCoreController: def __init__(self): self.__list_merge = None self.__map = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], ] self.__list_empty_location = [] @property def map(self): return self.__map def __zero_to_end(self): \"\"\" 零元素移动到末尾. \"\"\" for i in range(-1, -len(self.__list_merge) - 1, -1): if self.__list_merge[i] == 0: del self.__list_merge[i] self.__list_merge.append(0) def __merge(self): \"\"\" 合并 \"\"\" self.__zero_to_end() for i in range(len(self.__list_merge) - 1): if self.__list_merge[i] == self.__list_merge[i + 1]: self.__list_merge[i] += self.__list_merge[i + 1] del self.__list_merge[i + 1] self.__list_merge.append(0) def __move_left(self): \"\"\" 向左移动 \"\"\" for line in self.__map: self.__list_merge = line self.__merge() def __move_right(self): \"\"\" 向右移动 \"\"\" for line in self.__map: self.__list_merge = line[::-1] self.__merge() line[::-1] = self.__list_merge def __move_up(self): self.__square_matrix_transpose() self.__move_left() self.__square_matrix_transpose() def __move_down(self): self.__square_matrix_transpose() self.__move_right() self.__square_matrix_transpose() def __square_matrix_transpose(self): \"\"\" 方阵转置 :param sqr_matrix: 二维列表类型的方阵 \"\"\" for c in range(1, len(self.__map)): for r in range(c, len(self.__map)): self.__map[r][c - 1], self.__map[c - 1][r] = self.__map[c - 1][r], self.__map[r][c - 1] def move(self, dir): \"\"\" 移动 :param dir: 方向,DirectionModel类型 :return: \"\"\" if dir == DirectionModel.UP: self.__move_up() elif dir == DirectionModel.DOWN: self.__move_down() elif dir == DirectionModel.LEFT: self.__move_left() elif dir == DirectionModel.RIGHT: self.__move_right() # def generate_new_number(self): # # 思路:选出所有的空白位置(行／列),再随机挑选一个. # list_empty_location = [] # # for r in range(len(self.__map)):#0 1 2 3 # for c in range(len(self.__map[r])): # if self.__map[r][c] == 0: # # 记录r c --> 元组 # list_empty_location.append((r,c)) # 　　# 确定哪个空白位置1 0 # loc = random.choice(list_empty_location) # 　 　#　产生随机数 # 　　if random.randint(1,10) == 1: # self.__map[loc[0]][loc[1]] = 4 # else: # self.__map[loc[0]][loc[1]] = 2 def generate_new_number(self): \"\"\" 生成新数字 \"\"\" self.__get_empty_location() if len(self.__list_empty_location) == 0: return loc = random.choice(self.__list_empty_location) # if random.randint(1, 10) == 1: # self.__map[loc.r_index][loc.c_index] = 4 # else: # self.__map[loc.r_index][loc.c_index] = 2 self.__map[loc.r_index][loc.c_index] = self.__select_random_number() # 因为在该位置生成了新数字，所以该位置就不是空位置了． self.__list_empty_location.remove(loc) def __select_random_number(self): return 4 if random.randint(1, 10) == 1 else 2 def __get_empty_location(self): # 每次统计空位置，都先清空之前的数据，避免影响本次数据． self.__list_empty_location.clear() for r in range(len(self.__map)): for c in range(len(self.__map[r])): if self.__map[r][c] == 0: self.__list_empty_location.append(Location(r, c)) def is_game_over(self): \"\"\" 游戏是否结束 :return: False表示没有结束 True 表示结束 \"\"\" # 是否具有空位置 if len(self.__list_empty_location) > 0: return False # # 判断横向有没有相同的元素 # for r in range(len(self.__map)): # for c in range(len(self.__map[r]) - 1): # 0 1 2 # if self.__map[r][c] == self.__map[r][c + 1]: # return False # # # 判断竖向有没有相同的元素 # for c in range(4): # for r in range(3): # if self.__map[r][c] == self.__map[r + 1][c]: # return False for r in range(len(self.__map)):#0 for c in range(len(self.__map[r]) - 1): # 0 1 2 if self.__map[r][c] == self.__map[r][c + 1] or self.__map[c][r] == self.__map[c+1][r]: return False return True # ---------测试代码--------------- if __name__ == \"__main__\": controller = GameCoreController() # controller.move_left() # print(controller.map) # controller.move_down() # print(controller.map) # controller.move(DirectionModel.LEFT) # print(controller.map) # controller.move(DirectionModel.RIGHT) # print(controller.map) controller.generate_new_number() controller.generate_new_number() controller.generate_new_number() controller.generate_new_number() controller.is_game_over() print(controller.map) ２０４８控制台界面 ui.py \"\"\" ２０４８控制台界面 \"\"\" from bll import GameCoreController from model import DirectionModel import os class GameConsoleView: def __init__(self): self.__controller = GameCoreController() def main(self): self.__start() self.__update() def __start(self): # 产生两个数字 self.__controller.generate_new_number() self.__controller.generate_new_number() # 绘制界面 self.__draw_map() def __draw_map(self): # 清空控制台 os.system(\"clear\") for line in self.__controller.map: for item in line: print(item,end = \" \") print() def __update(self): # 循环 while True: # 判断玩家的输入　--> 移动地图 self.__move_map_for_input() # 产生新数字 self.__controller.generate_new_number() # 绘制界面 self.__draw_map() # 游戏结束判断 --> 提示 if self.__controller.is_game_over(): print(\"游戏结束\") break def __move_map_for_input(self): dir = input(\"请输入方向(wsas)\") dict_dir = { \"w\":DirectionModel.UP, \"s\":DirectionModel.DOWN, \"a\":DirectionModel.LEFT, \"d\":DirectionModel.RIGHT, } if dir in dict_dir: self.__controller.move(dict_dir[dir]) # ----------- if __name__ ==\"__main__\": view = GameConsoleView() view.main() Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:46:49 "},"exercise/student_management_system.html":{"url":"exercise/student_management_system.html","title":"学生管理系统","keywords":"","body":"学生管理系统 项目开发大致流程 MVC架构 项目计划 学生管理系统 项目计划： 1.完成数据模型类StudentModel 2.创建逻辑控制类StudentManagerController 3.完成数据：学生列表 __stu_list 4.行为：获取列表 stu_list, 5.添加学生方法 add_student 6.根据编号删除学生remove_student 7.根据编号修改学生update_student 8.在界面视图类中，根据编号删除学生. 9.在界面视图类中，根据编号修改学生信息. 信息管理系统详细设计 参考代码： class StudentModel: \"\"\" 学生模型 \"\"\" def __init__(self, name=\"\", age=0, score=0, id=0): \"\"\" 创建学生对象 :param name: 姓名,str类型. :param age: 年龄,int类型 :param score: 成绩,float类型 :param id: 编号(该学生对象的唯一标识) \"\"\" self.name = name self.age = age self.score = score self.id = id class StudentManagerController: \"\"\" 学生管理控制器,负责业务逻辑处理. \"\"\" # 类变量,表示初始编号. __init_id = 1000 def __init__(self): self.__stu_list = [] @property def stu_list(self): \"\"\" 学生列表 :return: 存储学生对象的列表 \"\"\" return self.__stu_list def add_student(self, stu_info): \"\"\" 添加一个新学生 :param stu_info: 没有编号的学生信息 \"\"\" stu_info.id = self.__generate_id() self.__stu_list.append(stu_info) def __generate_id(self): StudentManagerController.__init_id += 1 return StudentManagerController.__init_id def remove_student(self, id): \"\"\" 根据编号移除学生信息 :param id: 编号 :return: \"\"\" for item in self.__stu_list: if item.id == id: self.__stu_list.remove(item) return True # 表示移除成功 return False # 表示移除失败 def update_student(self, stu_info): \"\"\" 根据stu_info.id修改其他信息 :param stu_info: 学生对象 :return: 是否修改成功 \"\"\" for item in self.__stu_list: if item.id == stu_info.id: item.name = stu_info.name item.age = stu_info.age item.score = stu_info.score return True return False def order_by_score(self): \"\"\" 根据成绩，对self.__stu_list进行升序排列 \"\"\" for r in range(len(self.__stu_list) - 1): for c in range(r + 1, len(self.__stu_list)): if self.__stu_list[r].score > self.__stu_list[c].score: self.__stu_list[r], self.__stu_list[c] = self.__stu_list[c], self.__stu_list[r] \"\"\" # 测试添加学生功能 manager = StudentManagerController() s01 = StudentModel(\"zs\", 24, 100) manager.add_student(s01) manager.add_student(StudentModel(\"ls\", 24, 100)) for item in manager.stu_list: print(item.id, item.name) \"\"\" \"\"\" # 测试删除学生 manager = StudentManagerController() manager.add_student(StudentModel(\"zs\")) manager.add_student(StudentModel(\"ls\")) print(manager.remove_student(1005)) for item in manager.stu_list: print(item.id, item.name) \"\"\" \"\"\" # 测试修改功能 manager = StudentManagerController() manager.add_student(StudentModel(\"zs\")) for item in manager.stu_list: print(item.id, item.name, item.score, item.age) manager.update_student(StudentModel(\"张三\", 27, 84, 1001)) print(\"修改后...\") for item in manager.stu_list: print(item.id, item.name, item.score, item.age) \"\"\" class StudentManagerView: \"\"\" 学生管理器视图 \"\"\" def __init__(self): self.__manager = StudentManagerController() def __display_menu(self): print(\"1)添加学生\") print(\"2)显示学生\") print(\"3)删除学生\") print(\"4)修改学生\") print(\"5)按照成绩升序显示学生\") def __select_menu(self): item = input(\"请输入：\") if item == \"1\": self.__input_student() elif item == \"2\": self.__output_students(self.__manager.stu_list) elif item == \"3\": self.__delete_student() elif item == \"4\": self.__modify_student() elif item == \"5\": self.__output_student_by_score() def main(self): \"\"\" 界面视图入口 :return: \"\"\" while True: self.__display_menu() self.__select_menu() def __input_student(self): name = input(\"请输入姓名：\") age = int(input(\"请输入年龄：\")) score = int(input(\"请输入成绩：\")) stu = StudentModel(name, age, score) self.__manager.add_student(stu) def __output_students(self, list_output): for item in list_output: print(item.id, item.name, item.age, item.score) def __delete_student(self): id = int(input(\"请输入编号：\")) if self.__manager.remove_student(id): print(\"删除成功\") else: print(\"删除失败\") def __modify_student(self): stu = StudentModel() stu.id = int(input(\"请输入需要修改的学生编号:\")) stu.name = input(\"请输入新的学生名称：\") stu.age = int(input(\"请输入新的学生年龄：\")) stu.score = int(input(\"请输入新的学生成绩：\")) if self.__manager.update_student(stu): print(\"修改成功\") else: print(\"修改失败\") def __output_student_by_score(self): self.__manager.order_by_score() self.__output_students(self.__manager.stu_list) view = StudentManagerView() view.main() 学生管理系统添加学生内存图 MVC架构设计学生关系系统 入口 \"\"\" 程序入口 \"\"\" from ui import * # 限制只能从当前模块才执行。 if __name__ ==\"__main__\": view = StudentManagerView() view.main() 业务逻辑处理 \"\"\" 业务逻辑处理 \"\"\" class StudentManagerController: \"\"\" 学生管理控制器,负责业务逻辑处理. \"\"\" # 类变量,表示初始编号. __init_id = 1000 def __init__(self): self.__stu_list = [] @property def stu_list(self): \"\"\" 学生列表 :return: 存储学生对象的列表 \"\"\" return self.__stu_list def add_student(self, stu_info): \"\"\" 添加一个新学生 :param stu_info: 没有编号的学生信息 \"\"\" stu_info.id = self.__generate_id() self.__stu_list.append(stu_info) def __generate_id(self): StudentManagerController.__init_id += 1 return StudentManagerController.__init_id def remove_student(self, id): \"\"\" 根据编号移除学生信息 :param id: 编号 :return: \"\"\" for item in self.__stu_list: if item.id == id: self.__stu_list.remove(item) return True # 表示移除成功 return False # 表示移除失败 def update_student(self, stu_info): \"\"\" 根据stu_info.id修改其他信息 :param stu_info: 学生对象 :return: 是否修改成功 \"\"\" for item in self.__stu_list: if item.id == stu_info.id: item.name = stu_info.name item.age = stu_info.age item.score = stu_info.score return True return False def order_by_score(self): \"\"\" 根据成绩，对self.__stu_list进行升序排列 \"\"\" for r in range(len(self.__stu_list) - 1): for c in range(r + 1, len(self.__stu_list)): if self.__stu_list[r].score > self.__stu_list[c].score: self.__stu_list[r], self.__stu_list[c] = self.__stu_list[c], self.__stu_list[r] 界面代码 \"\"\" 界面代码 \"\"\" from bll import * from model import * class StudentManagerView: \"\"\" 学生管理器视图 \"\"\" def __init__(self): self.__manager = StudentManagerController() def __display_menu(self): print(\"1)添加学生\") print(\"2)显示学生\") print(\"3)删除学生\") print(\"4)修改学生\") print(\"5)按照成绩升序显示学生\") def __select_menu(self): item = input(\"请输入：\") if item == \"1\": self.__input_student() elif item == \"2\": self.__output_students(self.__manager.stu_list) elif item == \"3\": self.__delete_student() elif item == \"4\": self.__modify_student() elif item == \"5\": self.__output_student_by_score() def main(self): \"\"\" 界面视图入口 :return: \"\"\" while True: self.__display_menu() self.__select_menu() def __input_student(self): name = input(\"请输入姓名：\") age = int(input(\"请输入年龄：\")) score = int(input(\"请输入成绩：\")) stu = StudentModel(name, age, score) self.__manager.add_student(stu) def __output_students(self, list_output): for item in list_output: print(item.id, item.name, item.age, item.score) def __delete_student(self): id = int(input(\"请输入编号：\")) if self.__manager.remove_student(id): print(\"删除成功\") else: print(\"删除失败\") def __modify_student(self): stu = StudentModel() stu.id = int(input(\"请输入需要修改的学生编号:\")) stu.name = input(\"请输入新的学生名称：\") stu.age = int(input(\"请输入新的学生年龄：\")) stu.score = int(input(\"请输入新的学生成绩：\")) if self.__manager.update_student(stu): print(\"修改成功\") else: print(\"修改失败\") def __output_student_by_score(self): self.__manager.order_by_score() self.__output_students(self.__manager.stu_list) 定义数据模型 \"\"\" 定义数据模型 \"\"\" class StudentModel: \"\"\" 学生模型 \"\"\" def __init__(self, name=\"\", age=0, score=0, id=0): \"\"\" 创建学生对象 :param name: 姓名,str类型. :param age: 年龄,int类型 :param score: 成绩,float类型 :param id: 编号(该学生对象的唯一标识) \"\"\" self.name = name self.age = age self.score = score self.id = id Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:17:59 "},"exercise/dragon_eight.html":{"url":"exercise/dragon_eight.html","title":"天龙八部技能系统","keywords":"","body":"天龙八部技能系统 设计图分析 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 23:55:51 "},"exercise/list_helper.html":{"url":"exercise/list_helper.html","title":"集成操作框架","keywords":"","body":"集成操作框架 Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-02 11:15:18 "},"exercise/double_list_helper.html":{"url":"exercise/double_list_helper.html","title":"double_list_helper","keywords":"","body":"double_list_helper class Vector2: \"\"\" 二维向量 可以表示位置/方向 \"\"\" def __init__(self, x, y): self.x = x self.y = y @staticmethod def left(): return Vector2(0, -1) @staticmethod def right(): return Vector2(0, 1) @staticmethod def up(): return Vector2(-1, 0) @staticmethod def down(): return Vector2(1, 0) class DoubleListHelper: @staticmethod def get_elements(target, vect_pos, vect_dir, count): \"\"\" 在二维列表中获取指定位置，指定方向，指定数量的元素. :param target: 二维列表 :param vect_pos: 指定位置 :param vect_dir: 指定方向 :param count: 指定数量 :return: 列表 \"\"\" list_result = [] for i in range(count): vect_pos.x += vect_dir.x vect_pos.y += vect_dir.y element = target[vect_pos.x][vect_pos.y] list_result.append(element) return list_result Copyright © None.K.Sun 2019-2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-05 00:01:21 "}}